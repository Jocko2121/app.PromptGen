<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompt Generator - V2</title>
    <link rel="stylesheet" href="/styles/main.css">
    
    <!-- Database Viewer iframe styles -->
    <style>
        .database-viewer-iframe {
            width: 100%;
            height: 1500px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
            overflow: auto;
            min-height: 400px;
        }
    </style>
</head>
<body class="light-mode">
    <!-- Toast container - positioned at top level to survive DOM re-rendering -->
    <div id="toast-container"></div>

    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar__header">
                <h2>Prompt Gen</h2>
            </div>
            <div class="sidebar__content">
                <h4 class="sidebar__sub-heading">Prompt Sets ‚è≥</h4>
                <div id="prompt-sets-list" class="sidebar__list">
                </div>
                
                <h4 class="sidebar__sub-heading">Projects</h4>
                <ul id="library-list" class="sidebar__list">
                </ul>
            </div>
            <div class="sidebar__footer">
                <button id="admin-reset-button" data-action="adminReset">Admin: Hard Reset</button>
            </div>
        </aside>

        <div class="app-bar">
            <div class="app-bar__section app-bar__project">
                <span class="sidebar__hamburger" id="hamburger-button">&#9776;</span>
                <label for="project-name-input" class="project-hub__label">Project:</label>
                <input type="text" id="project-name-input" class="panel__title-input project-hub__input" data-action="projectTitleInput" placeholder="Enter project name...">
                <div class="panel__header-buttons">
                    <button id="save-project-button" class="btn btn--primary" data-action="saveProject" title="Save Project" aria-label="Save Project">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2H5zm7-14a4 4 0 1 0 0 8 4 4 0 0 0 0-8zM6 5v4h10V5H6z"/></svg>
                    </button>
                    <button id="save-as-project-button" class="btn btn--primary" data-action="saveAsProject" title="Save as New Project" aria-label="Save as New Project">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 1 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 9h-3v3H8v-3H5v-2h3V6h2v3h3v2z"/></svg>
                    </button>
                    <button id="delete-project-button" class="btn btn--danger" data-action="deleteCurrentProject" title="Delete Current Project" aria-label="Delete Current Project">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                            <path fill="currentColor" d="M7 4V2C7 1.45 7.45 1 8 1H16C16.55 1 17 1.45 17 2V4H20C20.55 4 21 4.45 21 5S20.55 6 20 6H19V19C19 20.1 18.1 21 17 21H7C5.9 21 5 20.1 5 19V6H4C3.45 6 3 5.55 3 5S3.45 4 4 4H7ZM9 3V4H15V3H9ZM7 6V19H17V6H7ZM9 8V17H11V8H9ZM13 8V17H15V8H13Z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="app-bar__section app-bar__tools"></div>
            <div class="app-bar__section app-bar__settings">
                <button class="btn btn--icon" title="Show Left Sidebar" aria-label="Show Left Sidebar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>
                        <line x1="9" x2="9" y1="3" y2="21"/>
                    </svg>
                </button>
                <button class="btn btn--icon" title="Split View" aria-label="Split View">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>
                        <line x1="3" x2="21" y1="15" y2="15"/>
                    </svg>
                </button>
                <button class="btn btn--icon" title="Show Right Sidebar" aria-label="Show Right Sidebar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>
                        <line x1="15" x2="15" y1="3" y2="21"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="main-content-wrapper">
            <div class="tab-bar" id="main-tab-bar">
                <div class="tab-bar__tabs">
                    <button class="tab-button active" data-tab-target="#prompt-builder-panel" data-action="switchTab">Prompt Builder</button>
                    <button class="tab-button" data-tab-target="#refinement-panel" data-action="switchTab">Refinement</button>
                    <button class="tab-button" data-tab-target="#text-transformer-panel" data-action="switchTab">Text Transformer</button>
                    <button class="tab-button" data-tab-target="#article-workspace-panel" data-action="switchTab">Article Workspace</button>
                    <!-- <button class="tab-button" data-tab-target="#settings-panel">Settings</button> -->
                </div>
                <div class="tab-bar__icons">
                    <button class="tab-button tab-button--icon" data-tab-target="#database-components-panel" data-action="switchTab" title="Database Components">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12 3C7.58 3 4 4.79 4 7s3.58 4 8 4s8-1.79 8-4s-3.58-4-8-4M4 9v3c0 2.21 3.58 4 8 4s8-1.79 8-4V9c0 2.21-3.58 4-8 4s-8-1.79-8-4m0 5v3c0 2.21 3.58 4 8 4s8-1.79 8-4v-3c0 2.21-3.58 4-8 4s-8-1.79-8-4"/>
                        </svg>
                    </button>
                    <button class="tab-button tab-button--icon" data-tab-target="#database-viewer-panel" data-action="switchTab" title="Database Viewer">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M3 3h18v18H3V3zm16 16V5H5v14h14zM7 7h10v2H7V7zm0 4h10v2H7v-2zm0 4h7v2H7v-2z"/>
                        </svg>
                    </button>
                    <button class="tab-button tab-button--icon" data-tab-target="#settings-panel" data-action="switchTab" title="Settings">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1 0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <main class="main-content">
                <section class="panel collapsible-panel tab-content active" id="prompt-builder-panel">
                    <div class="panel__header">
                        <h3>[set_name] ‚è≥</h3>
                        <div class="panel__header-buttons">
                             <button id="add-component-button" class="btn" data-action="addComponent">Add Component</button>
                        </div>
                        <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="prompt-builder__pallet" id="prompt-builder-pallet">
                                </div>
                            <div class="prompt-assembler__output">
                                                            <div class="generate-button-container">
                                <button id="assemble-all-button" class="btn btn--primary" data-action="assembleAll">Add All to Final Prompt</button>
                            </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="database-components-panel">
                    <div class="panel__header">
                        <h3>Database Components üåê ‚òπ</h3>
                        <div style="display: flex; gap: 10px; align-items: center; margin-right: 20px;">
                            <button id="toggle-details-btn" class="btn" data-action="toggleAdminDetails">Show Details</button>
                            <button id="refresh-all-btn" class="btn" data-action="refreshAll">Refresh All</button>
                        </div>
                        <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper components-admin">
                            <div id="error-message" class="error error__message"></div>
                            <div id="components-grouped-view"></div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="database-viewer-panel">
                    <div class="panel__header">
                        <h3>Database Viewer ‚è≥</h3>
                        <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <iframe src="/db-viewer/" class="database-viewer-iframe"></iframe>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="refinement-panel">
                     <div class="panel__header">
                        <h3>Refinement ‚è≥</h3>
                         <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                     <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="refinement-area">
                                <div class="panel user-outline-panel">
                                    <div class="panel__header"><h3>User Outline ‚è≥</h3></div>
                                    <textarea id="userOutline-textarea" autocomplete="off" placeholder="Write your outline or dump your thoughts here..." data-action="contentBlockInput"></textarea>
                                    <div class="draft-controls" data-content-block="userOutline"> ‚è≥<select class="draft-controls__select" data-action="draftSelect"></select><button class="btn btn--draft-save" data-action="draftSave">Save</button><button class="btn btn--draft-delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                </div>
                                <div class="insert-button-container">
                                    <button id="insert-button" class="btn btn--primary" title="Insert Outline into Final Prompt" data-action="insertOutline">&rarr;</button>
                                </div>
                                <div class="panel final-prompt-panel">
                                    <div class="panel__header">
                                        <h3>Final Prompt ‚è≥</h3>
                                        <div class="panel__header-buttons">
                                                                        <button id="copy-button" class="btn" data-action="copyToClipboard">Copy</button>
                            <button id="clear-button" class="btn" data-action="clearContent">Clear</button>
                                        </div>
                                    </div>
                                    <textarea id="finalPrompt-textarea" autocomplete="off" placeholder="The final, combined prompt will appear here..." data-action="contentBlockInput"></textarea>
                                    <div class="draft-controls" data-content-block="finalPrompt"> ‚è≥<select class="draft-controls__select" data-action="draftSelect"></select><button class="btn btn--draft-save" data-action="draftSave">Save</button><button class="btn btn--draft-delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                </div>
                            </div>
                        </div>
                     </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="text-transformer-panel">
                    <div class="panel__header">
                        <h3>Text Transformer ‚è≥</h3>
                        <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div id="action-engine-panel-content">
                                <div class="text-transformer__area">
                                    <div class="panel">
                                        <div class="panel__header"><h3>Input ‚è≥</h3></div>
                                        <textarea id="textTransformerInput-textarea" autocomplete="off" placeholder="Paste text here to transform it..." data-action="contentBlockInput"></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerInput"> ‚è≥<select class="draft-controls__select" data-action="draftSelect"></select><button class="btn btn--draft-save" data-action="draftSave">Save</button><button class="btn btn--draft-delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                    </div>
                                    <div class="text-transformer__actions-container">
                                                                <button class="btn btn--transformer-action" data-action="selectTextTransformerAction" data-transformer-action="summarize">Summarize</button>
                        <button class="btn btn--transformer-action" data-action="selectTextTransformerAction" data-transformer-action="rewrite">Rewrite</button>
                        <button class="btn btn--transformer-action" data-action="selectTextTransformerAction" data-transformer-action="analyze">Analyze</button>

                                        <div id="text-transformer-options-container"></div>

                                        <button id="transform-execute-button" class="btn btn--primary" data-action="executeTextTransform">Transform</button>
                                        <hr class="text-transformer__divider">
                                        <button class="btn text-transformer__action-button" data-action="copyUp" title="Copy Output to Input">‚Üë</button>
                                    </div>
                                    <div class="panel">
                                        <div class="panel__header"><h3>Output ‚è≥</h3></div>
                                        <textarea id="textTransformerOutput-textarea" autocomplete="off" placeholder="Transformed text will appear here..." data-action="contentBlockInput"></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerOutput"> ‚è≥<select class="draft-controls__select" data-action="draftSelect"></select><button class="btn btn--draft-save" data-action="draftSave">Save</button><button class="btn btn--draft-delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="article-workspace-panel">
                    <div class="panel__header">
                        <h3>Article Workspace ‚è≥</h3>
                        <span class="collapsible-panel__icon" data-action="togglePanel">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <textarea id="articleWorkspace-textarea" autocomplete="off" placeholder="Paste the final draft created by the LLM here..." data-action="contentBlockInput"></textarea>
                            <div class="draft-controls" data-content-block="articleWorkspace"> ‚è≥<select class="draft-controls__select" data-action="draftSelect"></select><button class="btn btn--draft-save" data-action="draftSave">Save</button><button class="btn btn--draft-delete" data-action="draftDelete">üóëÔ∏è</button></div>
                        </div>
                    </div>
                </section>
                
                <section class="panel tab-content" id="settings-panel">
                    <div class="panel__header">
                        <h3>Settings üåê</h3>
                    </div>
                    <div class="settings-panel__content">
                        <div class="settings-group">
                            <h4>Theme üåê</h4>
                            <div class="settings-group__control">
                                                            <button id="theme-light-button" class="btn btn--icon hidden">‚òÄÔ∏è</button>
                            <button id="theme-dark-button" class="btn btn--icon">üåô</button>
                            </div>
                        </div>
                        <div class="settings-group">
                            <h4>Database</h4>
                            <div class="settings-group__control">
                                <a href="/db-viewer/" target="_blank" class="btn">Open Database Viewer</a>
                            </div>
                        </div>
                    </div>
                </section>

            </main>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /*
            * == AI PROMPT GENERATOR V2 - ARCHITECTURE BRIEFING ==
            *
            * GUIDING PRINCIPLES:
            * - The application is a state-driven, single-page app. All UI is rendered from the 'appState' object.
            * - The core data model is a "Project," which contains all settings and content drafts. A "Project" is represented by the 'activeProject' object within the main 'appState'.
            * - All data saving/loading (Drafts and Projects) is IN-MEMORY for this wireframe. No persistent storage is used. Reloading the page will reset everything.
            */

            // --- UI-ONLY EVENT LISTENERS ---
            function setupUIEventListeners() {
                const hamburgerButton = document.getElementById('hamburger-button');
                const sidebar = document.getElementById('sidebar');
                const lightThemeButton = document.getElementById('theme-light-button');
                const darkThemeButton = document.getElementById('theme-dark-button');
                const body = document.body;
                const dbToggleButton = document.getElementById('toggle-database-section');
                const dbPanel = document.getElementById('database-components-panel');

                if (hamburgerButton && sidebar) {
                    hamburgerButton.addEventListener('click', () => {
                        sidebar.classList.toggle('sidebar--collapsed');
                    });
                }

                if(lightThemeButton && darkThemeButton && body) {
                    lightThemeButton.addEventListener('click', () => {
                        body.classList.add('light-mode');
                        lightThemeButton.classList.add('hidden');
                        darkThemeButton.classList.remove('hidden');
                    });
                    darkThemeButton.addEventListener('click', () => {
                        body.classList.remove('light-mode');
                        darkThemeButton.classList.add('hidden');
                        lightThemeButton.classList.remove('hidden');
                    });
                }

                if (dbToggleButton && dbPanel) {
                    dbToggleButton.addEventListener('click', () => {
                        const isVisible = dbPanel.style.display !== 'none';
                        dbPanel.style.display = isVisible ? 'none' : '';
                        // Using new btn system
                        dbToggleButton.classList.toggle('btn--primary', !isVisible);
                        dbToggleButton.classList.toggle('btn', isVisible);
                    });
                }
            }


            // --- DATA MODELS (CONSTANTS) ---
            // ACTIVE: builderComponentData is populated from database and used for UI dropdowns & component renaming
            let builderComponentData = {};

            // --- APPLICATION STATE (UI & TEMPORARY STATE ONLY) ---
            function getDefaultAppState() {
                return {
                    // === DATABASE-BACKED STATE (CACHED) ===
                    currentProjectId: 1,
                    currentProjectName: 'Default Project',
                    availableProjects: [],
                    activePromptSet: 'custom_build',
                    
                    // === UI-ONLY STATE ===
                    ui: {
                        expandedPanels: {},
                        selectedTabs: {},
                        unsavedChanges: false,
                        lastSaveTime: null
                    },
                    
                    // === TEMPORARY INPUT STATE ===
                    tempInput: {
                        projectName: '',
                        textareaValues: {}, // Temporary text being typed
                        componentEdits: {}   // Unsaved component changes
                    },
                    
                    // === CACHED DATA (TO AVOID API CALLS) ===
                    cache: {
                        components: [],
                        componentTypes: [],
                        promptSets: [],
                        visibility: [],
                        contentBlocks: {},
                        settings: {},
                        lastRefresh: null
                    },
                    
                    // === WORKSPACE STATE & COMPATIBILITY LAYER ===
                    // Mixed usage: Some structures are core workspace state, others are legacy compatibility
                    activeProject: {
                        builder: {},              // CORE WORKSPACE STATE - Primary data structure for prompt composition
                                                 //    Used by: component selection, text editing, active/inactive states, renaming
                        components: [],          // UNUSED - Legacy database cache structure  
                        promptSets: [],          // MINIMAL USE - Only used during component type renaming operations
                        visibility: [],          // UNUSED - Legacy visibility cache structure
                        contentBlocks: {},       // UNUSED - Legacy content management (wireframe only)
                        textTransformer: {       // UNUSED - Legacy text transformer state (wireframe only)
                            activeAction: 'analyze',
                            actions: {
                                summarize: {},
                                rewrite: {
                                    activeOption: 'casual',
                                    options: {
                                        professional: 'Rewrite in a professional tone.',
                                        casual: 'Rewrite in a casual tone.',
                                        empathetic: 'Rewrite with more empathy.'
                                    }
                                },
                                analyze: {
                                    activeOption: 'proofread',
                                    options: {
                                        proofread: 'Proofread for grammar & spelling.',
                                        identify_themes: 'Identify the main themes.',
                                        fact_check: 'Fact-check for accuracy.'
                                    }
                                }
                            }
                        }
                    }
                };
            }

            let appState = {
                // === DATABASE CACHE LAYER ===
                // Fresh data fetched from API endpoints, used to populate UI components
                cache: {
                    components: [],      // Project components from /api/components
                    promptSets: [],      // Available prompt sets from database
                    visibility: [],      // Component visibility settings per prompt set
                    contentBlocks: [],   // UNUSED - Content blocks handled differently
                    drafts: [],          // UNUSED - Drafts handled differently  
                    settings: {}         // UNUSED - Settings handled differently
                },
                
                // === PROJECT CONTEXT ===
                // Tracks which project is currently active and loaded
                currentProjectId: 1,     // Active project ID (1 = Default Project)
                currentProjectName: '',  // Display name of active project
                projects: [],            // Full project list from /api/projects
                
                // === UI STATE TRACKING ===
                // Temporary state for user interactions and unsaved changes
                unsavedChanges: false,   // UNUSED - No save system implemented yet
                tempInput: {             // UNUSED - Temporary input tracking not implemented
                    projectName: '',
                    componentContent: {},
                    contentBlocks: {}
                },
                
                // === FUNCTIONAL COMPATIBILITY LAYER ===
                // Mix of active functionality and legacy structures (see detailed comments above)
                activeProject: getDefaultAppState(),  // Contains core builder workspace state
                activePromptSet: 'basic',             // ACTIVE - Current prompt set key, used by initialization & UI updates
                builderComponentData: {},             // ACTIVE - UI lookup structure for dropdowns & component renaming
                
                // === DEPRECATED STRUCTURES ===
                // Kept to prevent breaking changes, but not actively used
                savedProjects: [],       // COMPLETELY UNUSED - No handlers implemented, docs reference legacy design
                availableProjects: []    // MINIMAL USE - Backward compatibility alias, set but never read
            };

            // --- RENDER FUNCTIONS --- 
            // ELIMINATED: All render() functions and calls removed from main app 
            // Replaced with direct database-to-DOM initialization pattern

            // --- DATABASE-TO-DOM INITIALIZATION ---
            async function initializePromptSetsFromDatabase() {
                try {
                    const response = await fetch('/api/components');
                    const data = await response.json();
                    
                    const promptSetsContainer = document.getElementById('prompt-sets-list');
                    if (!promptSetsContainer) return;
                    
                    promptSetsContainer.innerHTML = '';
                    
                    // Load project settings to get active prompt set
                    let activePromptSet = 'custom_build'; // Default fallback
                    try {
                        const settingsResponse = await fetch(`/api/projects/${appState.currentProjectId}`);
                        const settingsData = await settingsResponse.json();
                        
                        if (settingsData.project && settingsData.project.settings && settingsData.project.settings.ui_settings) {
                            const uiSettings = JSON.parse(settingsData.project.settings.ui_settings);
                            if (uiSettings.activePromptSet) {
                                activePromptSet = uiSettings.activePromptSet;
                            }
                        }
                        
                        // Store settings in appState for later use
                        appState.currentProjectSettings = settingsData.project?.settings || {};
                    } catch (settingsError) {
                        console.warn('Could not load project settings, using default prompt set:', settingsError);
                    }
                    
                    if (data.promptSets) {
                        data.promptSets.forEach(set => {
                            const div = document.createElement('div');
                            div.className = 'prompt-set-selector';
                            div.dataset.promptSetKey = set.set_key;
                            div.setAttribute('data-action', 'changePromptSet');
                            div.textContent = set.display_name;
                            
                            // Mark active prompt set
                            if (set.set_key === activePromptSet) {
                                div.classList.add('active');
                                appState.activePromptSet = set.set_key;
                                
                                // Update Prompt Builder header immediately
                                updatePromptBuilderHeader(set.set_key);
                            }
                            
                            promptSetsContainer.appendChild(div);
                        });
                    }
                } catch (error) {
                    console.error('Error initializing prompt sets:', error);
                }
            }

            async function initializeProjectLibraryFromDatabase() {
                try {
                    console.log('üîÑ Starting Project Library initialization...');
                    
                    const response = await fetch('/api/projects');
                    console.log('üì° Projects API response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üìä Projects data received:', data);
                    
                    const projects = data.projects || data;
                    console.log('üìã Projects array:', projects);
                    
                    const libraryList = document.getElementById('library-list');
                    if (!libraryList) {
                        console.error('‚ùå Could not find #library-list element');
                        return;
                    }
                    
                    console.log('üéØ Found library-list element, clearing and populating...');
                    libraryList.innerHTML = '';

                    // Add "Create New Project" button
                    const createLi = document.createElement('li');
                    createLi.className = 'project-create-button';
                    createLi.innerHTML = '<span data-action="createProject">+ Create New Project</span>';
                    createLi.style.fontStyle = 'italic';
                    createLi.style.color = 'var(--primary-color)';
                    createLi.style.cursor = 'pointer';
                    libraryList.appendChild(createLi);
                    console.log('‚ûï Added Create New Project button');

                    // Add all projects
                    if (projects && projects.length > 0) {
                        projects.forEach((project, index) => {
                            console.log(`üìÅ Adding project ${index + 1}:`, project);
                            
                            const li = document.createElement('li');
                            if (project.id === appState.currentProjectId) {
                                li.className = 'active';
                                console.log(`‚úÖ Marked project ${project.id} as active`);
                            }

                            const textSpan = document.createElement('span');
                            textSpan.textContent = project.name;
                            textSpan.style.flexGrow = '1';
                            textSpan.setAttribute('data-action', 'loadProject');

                            li.appendChild(textSpan);
                            li.dataset.projectId = project.id;
                            libraryList.appendChild(li);
                        });
                        console.log(`‚úÖ Added ${projects.length} projects to library`);
                    } else {
                        console.warn('‚ö†Ô∏è No projects found in response');
                    }
                    
                    // Store projects in appState for future use
                    appState.projects = projects;
                    appState.availableProjects = projects; // Backward compatibility
                    
                    console.log('‚úÖ Project Library initialization completed successfully');
                    
                } catch (error) {
                    console.error('‚ùå Error initializing project library:', error);
                    
                    // Show error message in the UI
                    const libraryList = document.getElementById('library-list');
                    if (libraryList) {
                        libraryList.innerHTML = `
                            <li style="color: red; font-style: italic;">
                                Error loading projects: ${error.message}
                            </li>
                        `;
                    }
                }
            }

            async function initializeProjectHubFromDatabase() {
                try {
                    const response = await fetch(`/api/projects/${appState.currentProjectId}`);
                    const data = await response.json();
                    
                    const projectTitleInput = document.getElementById('project-name-input');
                    if (projectTitleInput && data.project) {
                        projectTitleInput.value = data.project.name;
                        appState.currentProjectName = data.project.name;
                    }
                } catch (error) {
                    console.error('Error initializing project hub:', error);
                }
            }

            async function initializePromptBuilderFromDatabase() {
                try {
                    console.log('üîÑ Loading Prompt Builder components from database...');
                    
                    const response = await fetch('/api/components');
                    const data = await response.json();
                    console.log('üìä Components data received:', data);
                    
                    const palletContainer = document.getElementById('prompt-builder-pallet');
                    if (!palletContainer) {
                        console.error('‚ùå Could not find #prompt-builder-pallet element');
                        return;
                    }
                    
                    // Store component data in appState for future use
                    appState.cache.components = data.components || [];
                    appState.cache.componentTypes = data.types || [];
                    appState.cache.promptSets = data.promptSets || [];
                    appState.cache.visibility = data.visibility || [];
                    
                    // Build builderComponentData for future compatibility
                    appState.builderComponentData = {};
                    if (data.types) {
                        data.types.forEach(type => {
                            appState.builderComponentData[type.type_key] = {
                                title: type.display_name,
                                prompts: {}
                            };
                        });
                    }
                    
                    // Populate prompts from components
                    if (data.components) {
                        data.components.forEach(component => {
                            const typeData = appState.builderComponentData[component.type_key];
                            if (typeData && component.selection && component.prompt_value) {
                                if (!typeData.prompts) typeData.prompts = {};
                                typeData.prompts[component.selection] = component.prompt_value;
                            }
                        });
                    }
                    
                    // Clear the container and build the component interface
                    palletContainer.innerHTML = '';
                    
                    // Get active components for current project (for now, show all available types)
                    const activePromptSet = appState.activePromptSet || 'custom_build';
                    console.log(`üéØ Building components for active prompt set: ${activePromptSet}`);
                    
                    // Create components based on available types, filtered by visibility
                    if (data.types && data.types.length > 0) {
                        const visibleTypes = getVisibleComponentTypes(data.types, data.promptSets, data.visibility, activePromptSet);
                        
                        if (visibleTypes.length > 0) {
                            visibleTypes.forEach((type, index) => {
                                console.log(`üß© Creating component: ${type.display_name} (${type.type_key})`);
                                createPromptBuilderComponent(palletContainer, type, data.components, index);
                            });
                            
                            console.log(`‚úÖ Created ${visibleTypes.length} visible prompt builder components (${data.types.length - visibleTypes.length} hidden by visibility settings)`);
                        } else {
                            palletContainer.innerHTML = `
                                <div class="prompt-builder__no-components">
                                    <h4>No Components Available</h4>
                                    <p>No components are visible for the "${getPromptSetDisplayName(activePromptSet)}" prompt set.</p>
                                    <p>Go to the <strong>Database Components</strong> panel to enable component visibility.</p>
                                </div>
                            `;
                            console.log(`‚ö†Ô∏è No components visible for active prompt set: ${activePromptSet}`);
                        }
                    } else {
                        palletContainer.innerHTML = '<p>No component types found in database.</p>';
                        console.warn('‚ö†Ô∏è No component types found');
                    }
                    
                    console.log('‚úÖ Prompt Builder initialized successfully');
                    
                } catch (error) {
                    console.error('‚ùå Error initializing prompt builder:', error);
                    
                    const palletContainer = document.getElementById('prompt-builder-pallet');
                    if (palletContainer) {
                        palletContainer.innerHTML = `
                            <p style="color: red; font-style: italic;">
                                Error loading prompt builder: ${error.message}
                            </p>
                        `;
                    }
                }
            }

            function createPromptBuilderComponent(container, componentType, components, index) {
                // Find active components of this type
                const typeComponents = components.filter(c => c.type_key === componentType.type_key && c.is_active);
                
                // Create the component wrapper
                const componentDiv = document.createElement('div');
                componentDiv.className = 'prompt-builder__component';
                componentDiv.dataset.componentType = componentType.type_key;
                
                // Create component header
                const header = document.createElement('div');
                header.className = 'component__header';
                
                const title = document.createElement('h4');
                title.textContent = componentType.display_name;
                title.className = 'component-title';
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'component__remove-button';
                removeBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                        <path fill="currentColor" d="M7 4V2C7 1.45 7.45 1 8 1H16C16.55 1 17 1.45 17 2V4H20C20.55 4 21 4.45 21 5S20.55 6 20 6H19V19C19 20.1 18.1 21 17 21H7C5.9 21 5 20.1 5 19V6H4C3.45 6 3 5.55 3 5S3.45 4 4 4H7ZM9 3V4H15V3H9ZM7 6V19H17V6H7ZM9 8V17H11V8H9ZM13 8V17H15V8H13Z"/>
                    </svg>
                `;
                removeBtn.setAttribute('data-action', 'removeComponent');
                removeBtn.dataset.componentType = componentType.type_key;
                removeBtn.title = `Remove ${componentType.display_name}`;
                
                header.appendChild(title);
                header.appendChild(removeBtn);
                
                // Create component controls
                const controls = document.createElement('div');
                controls.className = 'component__controls';
                
                // Create selection dropdown
                const select = document.createElement('select');
                select.className = 'component-select';
                select.setAttribute('data-action', 'componentSelect');
                select.dataset.componentType = componentType.type_key;
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Select a prompt...';
                select.appendChild(defaultOption);
                
                // Add options from active components only
                const uniqueSelections = new Set();
                typeComponents.forEach(component => {
                    if (component.selection && !uniqueSelections.has(component.selection)) {
                        uniqueSelections.add(component.selection);
                        const option = document.createElement('option');
                        option.value = component.selection;
                        option.textContent = component.selection;
                        select.appendChild(option);
                    }
                });
                
                // Add "Write My Own..." option
                const customOption = document.createElement('option');
                customOption.value = 'custom';
                customOption.textContent = 'Write My Own...';
                select.appendChild(customOption);
                
                // Create textarea for prompt content
                const textarea = document.createElement('textarea');
                textarea.className = 'component-textarea';
                textarea.placeholder = `Enter your ${componentType.display_name.toLowerCase()} prompt...`;
                textarea.rows = 4;
                textarea.setAttribute('data-action', 'componentInput');
                textarea.dataset.componentType = componentType.type_key;
                
                controls.appendChild(select);
                controls.appendChild(textarea);
                
                // Assemble the component
                componentDiv.appendChild(header);
                componentDiv.appendChild(controls);
                
                container.appendChild(componentDiv);
                
                console.log(`üé® Created component interface for: ${componentType.display_name}`);
            }

            async function initializeContentBlocksFromDatabase() {
                try {
                    // For now, just initialize empty content blocks
                    // This will be expanded when we implement the draft system
                    const contentBlockTypes = ['userOutline', 'finalPrompt', 'articleWorkspace', 'textTransformerInput', 'textTransformerOutput'];
                    
                    contentBlockTypes.forEach(blockType => {
                        const textarea = document.getElementById(`${blockType}-textarea`);
                        const draftControls = document.querySelector(`.draft-controls[data-content-block="${blockType}"]`);
                        
                        if (textarea) {
                            textarea.value = ''; // Start with empty content
                        }
                        
                        if (draftControls) {
                            const select = draftControls.querySelector('.draft-controls__select');
                            const deleteBtn = draftControls.querySelector('.btn--draft-delete');
                            
                            if (select) {
                                select.innerHTML = '<option value="draft-1">Draft 1 - New</option>';
                            }
                            
                            if (deleteBtn) {
                                deleteBtn.disabled = true; // Only one draft initially
                            }
                        }
                    });
                    
                } catch (error) {
                    console.error('Error initializing content blocks:', error);
                }
            }

            async function initializeTextTransformerFromDatabase() {
                try {
                    // Initialize text transformer with default state
                    const actionButtons = document.querySelectorAll('.btn--transformer-action');
                    const optionsContainer = document.getElementById('text-transformer-options-container');
                    
                    // Set default active action
                    actionButtons.forEach(button => {
                        button.classList.toggle('btn--active', button.dataset.transformerAction === 'analyze');
                    });
                    
                    // Set default options for analyze
                    if (optionsContainer) {
                        optionsContainer.innerHTML = `
                            <label><input type="radio" name="analyze-options" value="proofread" checked data-action="selectTextTransformerOption">Proofread for grammar & spelling.</label>
                            <label><input type="radio" name="analyze-options" value="identify_themes" data-action="selectTextTransformerOption">Identify the main themes.</label>
                            <label><input type="radio" name="analyze-options" value="fact_check" data-action="selectTextTransformerOption">Fact-check for accuracy.</label>
                        `;
                    }
                    
                } catch (error) {
                    console.error('Error initializing text transformer:', error);
                }
            }

            async function initializeDatabaseComponentsFromDatabase() {
                try {
                    console.log('üîÑ Loading Database Components admin panel...');
                    const response = await fetch('/api/components');
                    const data = await response.json();
                    
                    const groupedView = document.getElementById('components-grouped-view');
                    if (!groupedView) return;
                    
                    // Store data for future use
                    appState.cache.components = data.components || [];
                    appState.cache.componentTypes = data.types || [];
                    appState.cache.promptSets = data.promptSets || [];
                    appState.cache.visibility = data.visibility || [];
                    
                    // Render the admin interface
                    renderDatabaseComponentsAdmin(groupedView, data);
                    
                    console.log('‚úÖ Database Components admin panel loaded successfully');
                    
                } catch (error) {
                    console.error('Error initializing database components:', error);
                    const groupedView = document.getElementById('components-grouped-view');
                    if (groupedView) {
                        groupedView.innerHTML = '<div class="error">Failed to load database components. Please try refreshing the page.</div>';
                    }
                }
            }

            function renderDatabaseComponentsAdmin(container, data) {
                const { types, components, promptSets, visibility } = data;
                
                // Group components by type for display
                const componentsByType = {};
                components.forEach(comp => {
                    const type = types.find(t => t.id === comp.component_type_id);
                    if (type) {
                        if (!componentsByType[type.type_key]) {
                            componentsByType[type.type_key] = {
                                type: type,
                                components: []
                            };
                        }
                        componentsByType[type.type_key].components.push(comp);
                    }
                });

                // Build the original admin interface structure
                let html = '';

                // Add each component type group
                Object.values(componentsByType).forEach(({ type, components: typeComponents }) => {
                    html += `
                        <div class="component-group">
                            <div class="group-title">
                                <div class="group-title__row">
                                    <div class="group-title__container">
                                        <div class="group-title__label">
                                            <input type="text" 
                                                   class="group-title__editable-text" 
                                                   value="${type.display_name}" 
                                                   data-action="componentRename" 
                                                   data-original-type="${type.type_key}">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="component-group__layout">
                                <div class="component-group__table-container">
                                <table id="component-table--${type.type_key}">
                                    <thead>
                                        <tr>
                                            <th class="table__header--active">Active</th>
                                            <th class="table__header--selection">Selection</th>
                                            <th class="table__header--prompt">Prompt Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                    `;

                    // Add each component row
                    typeComponents.forEach(comp => {
                        html += `
                            <tr>
                                <td class="table__cell--active">
                                    <input type="checkbox" ${comp.is_active ? 'checked' : ''} 
                                           data-action="componentActiveToggle" 
                                           data-component-id="${comp.id}">
                                </td>
                                <td class="table__cell--selection">
                                    <input type="text" 
                                           class="input--selection" 
                                           value="${comp.selection}" 
                                           data-action="adminSelectionBlur"
                                           data-component-id="${comp.id}">
                                </td>
                                <td class="table__cell--prompt">
                                    <textarea class="textarea--prompt" 
                                              data-action="componentInput" 
                                              data-component-id="${comp.id}">${comp.prompt_value || ''}</textarea>
                                </td>
                            </tr>
                        `;
                    });

                    html += `
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div class="component-group__content-box">
                                    <h4>Prompt Set Visibility</h4>
                                    <p>Configure which prompt sets show this component type.</p>
                    `;

                    // Add prompt set checkboxes
                    promptSets.forEach(ps => {
                        const isVisible = visibility.some(v => 
                            v.component_type_id === type.id && 
                            v.prompt_set_id === ps.id && 
                            v.is_visible
                        );
                        
                        html += `
                            <div class="component-group__prompt-set-item ${isVisible ? 'component-group__prompt-set-item--active' : ''}">
                                <input type="checkbox" 
                                       class="component-group__prompt-set-checkbox" 
                                       ${isVisible ? 'checked' : ''}
                                       data-action="componentGroupCheckbox"
                                       data-prompt-set-id="${ps.id}"
                                       data-component-type-id="${type.id}">
                                <span class="component-group__prompt-set-name">${ps.display_name}</span>
                                <span class="component-group__status-text ${isVisible ? 'component-group__status-text--active' : ''}">
                                    ${isVisible ? 'Visible' : 'Hidden'}
                                </span>
                            </div>
                        `;
                    });

                    html += `
                                </div>
                                                            </div>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            // Helper functions for admin actions
            async function refreshDatabaseComponents() {
                console.log('üîÑ Refreshing database components...');
                await initializeDatabaseComponentsFromDatabase();
            }

            function exportDatabaseData() {
                const data = {
                    components: appState.cache.components,
                    types: appState.cache.componentTypes,
                    promptSets: appState.cache.promptSets,
                    visibility: appState.cache.visibility,
                    exported_at: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `database-components-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('üìÅ Database data exported successfully');
            }

            // --- MASTER INITIALIZATION FUNCTION ---
            async function initializeAllTabsFromDatabase() {
                console.log('üöÄ Initializing all tabs directly from database...');
                console.log('üìä Current appState:', appState);
                
                try {
                    // Initialize Prompt Sets FIRST to load active prompt set into appState
                    console.log('üîÑ Initializing Prompt Sets first (required for active prompt set)...');
                    try {
                        await initializePromptSetsFromDatabase();
                        console.log('‚úÖ Prompt Sets initialized successfully');
                    } catch (error) {
                        console.error('‚ùå Failed to initialize Prompt Sets:', error);
                    }
                    
                    // Then initialize remaining tabs in parallel
                    console.log('üîÑ Starting parallel initialization of remaining tabs...');
                    
                    const initPromises = [
                        { name: 'Project Library', fn: initializeProjectLibraryFromDatabase },
                        { name: 'Project Hub', fn: initializeProjectHubFromDatabase },
                        { name: 'Prompt Builder', fn: initializePromptBuilderFromDatabase },
                        { name: 'Content Blocks', fn: initializeContentBlocksFromDatabase },
                        { name: 'Text Transformer', fn: initializeTextTransformerFromDatabase },
                        { name: 'Database Components', fn: initializeDatabaseComponentsFromDatabase }
                    ];
                    
                    // Run remaining initialization functions with individual error handling
                    const results = await Promise.allSettled(
                        initPromises.map(async ({ name, fn }) => {
                            console.log(`‚è≥ Initializing ${name}...`);
                            try {
                                await fn();
                                console.log(`‚úÖ ${name} initialized successfully`);
                                return { name, success: true };
                            } catch (error) {
                                console.error(`‚ùå Failed to initialize ${name}:`, error);
                                return { name, success: false, error };
                            }
                        })
                    );
                    
                    // Report results (add 1 for Prompt Sets that was initialized first)
                    const successful = results.filter(r => r.value?.success).length + 1;
                    const failed = results.filter(r => !r.value?.success);
                    
                    console.log(`üìä Initialization Summary: ${successful}/${results.length + 1} successful`);
                    
                    if (failed.length > 0) {
                        console.warn('‚ö†Ô∏è Failed initializations:', failed.map(f => f.value?.name || 'Unknown'));
                    }
                    
                    console.log('‚úÖ All tabs initialization process completed');
                    
                } catch (error) {
                    console.error('‚ùå Critical error during tab initialization:', error);
                }
            }

            // --- TARGETED UPDATE FUNCTIONS (Replace render() calls) ---
            function updateProjectTitleDisplay(newTitle) {
                const projectTitleInput = document.getElementById('project-name-input');
                if (projectTitleInput) {
                    projectTitleInput.value = newTitle;
                }
                appState.currentProjectName = newTitle;
            }

            async function updateProjectLibraryDisplay() {
                await initializeProjectLibraryFromDatabase();
            }

            function updatePromptSetActiveState(activeSetKey) {
                const promptSetSelectors = document.querySelectorAll('.prompt-set-selector');
                promptSetSelectors.forEach(selector => {
                    selector.classList.toggle('active', selector.dataset.promptSetKey === activeSetKey);
                });
                appState.activePromptSet = activeSetKey;
            }
            
            function updatePromptBuilderHeader(promptSetKey) {
                const promptBuilderHeader = document.querySelector('#prompt-builder-panel .panel__header h3');
                if (promptBuilderHeader) {
                    const displayName = getPromptSetDisplayName(promptSetKey);
                    promptBuilderHeader.textContent = displayName;
                    console.log(`üéØ Updated Prompt Builder header to: ${displayName}`);
                }
            }
            
            function getPromptSetDisplayName(promptSetKey) {
                if (appState.cache && appState.cache.promptSets) {
                    const promptSet = appState.cache.promptSets.find(ps => ps.set_key === promptSetKey);
                    return promptSet ? promptSet.display_name : promptSetKey;
                }
                return promptSetKey;
            }
            
            function updateVisibilityUIState(checkbox, isVisible) {
                // Update the parent container's active state
                const parentItem = checkbox.closest('.component-group__prompt-set-item');
                if (parentItem) {
                    parentItem.classList.toggle('component-group__prompt-set-item--active', isVisible);
                }
                
                // Update the status text
                const statusText = parentItem?.querySelector('.component-group__status-text');
                if (statusText) {
                    statusText.textContent = isVisible ? 'Visible' : 'Hidden';
                    statusText.classList.toggle('component-group__status-text--active', isVisible);
                }
            }
            
            function updateVisibilityCache(promptSetId, componentTypeId, isVisible) {
                if (!appState.cache || !appState.cache.visibility) {
                    return;
                }
                
                // Find existing visibility record
                const existingIndex = appState.cache.visibility.findIndex(v => 
                    v.prompt_set_id === promptSetId && v.component_type_id === componentTypeId
                );
                
                if (existingIndex >= 0) {
                    // Update existing record
                    appState.cache.visibility[existingIndex].is_visible = isVisible;
                } else {
                    // Add new record
                    appState.cache.visibility.push({
                        prompt_set_id: promptSetId,
                        component_type_id: componentTypeId,
                        is_visible: isVisible
                    });
                }
            }
            
            function getVisibleComponentTypes(types, promptSets, visibility, activePromptSetKey) {
                if (!types || !promptSets || !visibility) {
                    console.warn('‚ö†Ô∏è Missing data for visibility filtering, showing all components');
                    return types;
                }
                
                // Find the active prompt set
                const activePromptSet = promptSets.find(ps => ps.set_key === activePromptSetKey);
                if (!activePromptSet) {
                    console.warn(`‚ö†Ô∏è Active prompt set "${activePromptSetKey}" not found, showing all components`);
                    return types;
                }
                
                // Filter types based on visibility settings
                const visibleTypes = types.filter(type => {
                    const visibilityRecord = visibility.find(v => 
                        v.prompt_set_id === activePromptSet.id && 
                        v.component_type_id === type.id
                    );
                    
                    // If no visibility record exists, component is hidden by default
                    // Only show components that have explicit visibility = true
                    const isVisible = visibilityRecord ? visibilityRecord.is_visible : false;
                    
                    if (isVisible) {
                        console.log(`üëÅÔ∏è Component "${type.display_name}" is visible for prompt set "${activePromptSetKey}"`);
                    } else {
                        console.log(`üö´ Component "${type.display_name}" is hidden for prompt set "${activePromptSetKey}"`);
                    }
                    
                    return isVisible;
                });
                
                console.log(`üîç Visibility filtering: ${visibleTypes.length}/${types.length} components visible for "${activePromptSetKey}"`);
                return visibleTypes;
            }

            // --- EVENT HANDLER FUNCTIONS ---
            // Project & Library Management Handlers
            function handleProjectSave(target, event) {
                console.log('Project save requested');
                // REMOVAL CANDIDATE: Manual save not needed - projects auto-save to database
            }

            function handleProjectSaveAs(target, event) {
                console.log('Project save as requested');
                // REMOVAL CANDIDATE: Save-as not needed - use "Create New Project" instead
            }

            function handleProjectLoad(target, event) {
                const projectId = parseInt(target.dataset.projectId) || parseInt(target.closest('[data-project-id]')?.dataset.projectId);
                
                if (!projectId) {
                    console.error('No project ID found for load operation');
                    return;
                }
                
                console.log('Loading project:', projectId);
                loadProject(projectId);
            }

            async function loadProject(projectId) {
                try {
                    console.log(`üîÑ Loading project ${projectId}...`);
                    
                    // Update current project ID
                    appState.currentProjectId = projectId;
                    
                    // Fetch project data from API
                    const response = await fetch(`/api/projects/${projectId}`);
                    if (!response.ok) {
                        throw new Error(`Failed to load project: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üìä Project data loaded:', data);
                    
                    // Update appState with project data
                    if (data.project) {
                        appState.currentProjectName = data.project.name;
                        console.log(`‚úÖ Switched to project: "${data.project.name}"`);
                    }
                    
                    // Update UI elements
                    await updateProjectLoadUI(projectId, data);
                    
                    console.log(`‚úÖ Project ${projectId} loaded successfully`);
                    
                } catch (error) {
                    console.error('‚ùå Error loading project:', error);
                    
                    // Show error to user
                    alert(`Failed to load project: ${error.message}`);
                }
            }

            async function updateProjectLoadUI(projectId, projectData) {
                // Update project title in Project Hub
                const projectTitleInput = document.getElementById('project-name-input');
                if (projectTitleInput && projectData.project) {
                    projectTitleInput.value = projectData.project.name;
                    console.log('üìù Updated project title input');
                }
                
                // Update active state in project library
                const libraryItems = document.querySelectorAll('#library-list li[data-project-id]');
                libraryItems.forEach(item => {
                    const itemProjectId = parseInt(item.dataset.projectId);
                    if (itemProjectId === projectId) {
                        item.classList.add('active');
                        console.log(`‚úÖ Marked project ${projectId} as active in library`);
                    } else {
                        item.classList.remove('active');
                    }
                });
                
                // Update other tabs with project-specific data
                // For now, we'll just refresh the basic initialization
                // Later we can add more sophisticated project-specific loading
                
                console.log('üéØ UI updated for project switch');
            }

            function handleDeleteCurrentProject(target, event) {
                const currentProjectId = appState.currentProjectId;
                const projectTitleInput = document.getElementById('project-name-input');
                const currentProjectName = projectTitleInput?.value || `Project ${currentProjectId}`;
                
                console.log('Delete current project requested:', currentProjectId, currentProjectName);
                
                // Prevent deletion of Default Project
                if (currentProjectId === 1) {
                    alert('Cannot delete the Default Project.');
                    return;
                }
                
                // Confirm deletion
                const confirmed = confirm(`Are you sure you want to delete "${currentProjectName}"?\n\nThis action cannot be undone.`);
                
                if (confirmed) {
                    console.log('Current project deletion confirmed:', currentProjectId);
                    deleteProject(currentProjectId, currentProjectName);
                } else {
                    console.log('Current project deletion cancelled:', currentProjectId);
                }
            }

            async function deleteProject(projectId, projectName) {
                try {
                    console.log(`üîÑ Deleting project ${projectId}: "${projectName}"...`);
                    
                    // Call API to delete project
                    const response = await fetch(`/api/projects/${projectId}`, {
                        method: 'DELETE'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to delete project: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üìä Project deletion response:', data);
                    
                    console.log(`‚úÖ Project "${projectName}" deleted successfully`);
                    
                    // If we deleted the currently active project, switch to Default Project
                    if (projectId === appState.currentProjectId) {
                        console.log('üîÑ Deleted project was active, switching to Default Project...');
                        await loadProject(1); // Switch to Default Project
                    }
                    
                    // Refresh the project library to remove the deleted project
                    await initializeProjectLibraryFromDatabase();
                    
                    console.log('üéØ Project library refreshed after deletion');
                    
                } catch (error) {
                    console.error('‚ùå Error deleting project:', error);
                    alert(`Failed to delete project: ${error.message}`);
                }
            }

            function createNewProject(target, event) {
                console.log('Create new project requested');
                
                // Prompt user for project name
                const projectName = prompt('Enter name for new project:');
                
                if (!projectName || projectName.trim() === '') {
                    console.log('Project creation cancelled - no name provided');
                    return;
                }
                
                console.log('Creating new project:', projectName.trim());
                createProject(projectName.trim());
            }

            async function createProject(projectName) {
                try {
                    console.log(`üîÑ Creating new project: "${projectName}"...`);
                    
                    // Call API to create project
                    const response = await fetch('/api/projects', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: projectName,
                            description: `New project: ${projectName}`
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to create project: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üìä Project creation response:', data);
                    
                    if (data.project) {
                        console.log(`‚úÖ Project created successfully: ID ${data.project.id}`);
                        
                        // Refresh the project library to show the new project
                        await initializeProjectLibraryFromDatabase();
                        
                        // Switch to the new project
                        await loadProject(data.project.id);
                        
                        console.log(`üéØ Switched to new project: "${data.project.name}"`);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error creating project:', error);
                    alert(`Failed to create project: ${error.message}`);
                }
            }

            function handleAdminReset(target, event) {
                console.log('Admin reset requested');
                // REMOVAL CANDIDATE: Admin reset never implemented - database operations handled differently
            }

            // Content Blocks & Drafts Handlers - REMOVAL CANDIDATES
            function handleDraftSave(target, event) {
                console.log('Draft save requested');
                // REMOVAL CANDIDATE: Draft system never implemented - content handled directly in textareas
            }

            function handleDraftDelete(target, event) {
                console.log('Draft delete requested');
                // REMOVAL CANDIDATE: Draft system never implemented - content handled directly in textareas
            }

            function handleDraftSelect(target, event) {
                console.log('Draft select requested:', target.value);
                // REMOVAL CANDIDATE: Draft system never implemented - content handled directly in textareas
            }

            function handleInsertOutline(target, event) {
                console.log('Insert outline requested');
                // REMOVAL CANDIDATE: Outline feature never implemented - users compose prompts manually
            }

            function handleCopyToClipboard(target, event) {
                console.log('Copy to clipboard requested');
                // REMOVAL CANDIDATE: Auto-copy never implemented - users copy manually from textareas
            }

            function handleClearContent(target, event) {
                console.log('Clear content requested');
                // REMOVAL CANDIDATE: Auto-clear never implemented - users clear textareas manually
            }

            // Text Transformer Handlers - REMOVAL CANDIDATES
            function handleTextTransformerAction(target, event) {
                console.log('Text transformer action selected:', target.dataset.transformerAction);
                // REMOVAL CANDIDATE: Text transformer never implemented - was wireframe concept only
            }

            function handleTextTransformerOption(target, event) {
                console.log('Text transformer option selected:', target.value);
                // REMOVAL CANDIDATE: Text transformer never implemented - was wireframe concept only
            }

            function handleTextTransformExecute(target, event) {
                console.log('Text transform execute requested');
                // REMOVAL CANDIDATE: Text transformer never implemented - was wireframe concept only
            }

            function handleTextCopyUp(target, event) {
                console.log('Text copy up requested');
                // REMOVAL CANDIDATE: Text transformer never implemented - was wireframe concept only
            }

            // Prompt Builder Handlers - REMOVAL CANDIDATES
            function handleAddComponent(target, event) {
                console.log('Add component requested');
                // REMOVAL CANDIDATE: Dynamic components never implemented - uses fixed database component types
            }

            function handleRemoveComponent(target, event) {
                console.log('Remove component requested');
                // REMOVAL CANDIDATE: Dynamic components never implemented - uses fixed database component types
            }

            function handleComponentSelect(target, event) {
                const componentType = target.dataset.componentType;
                const selectedValue = target.value;
                
                console.log(`üéØ Component select changed: ${componentType} = ${selectedValue}`);
                
                // Find the corresponding textarea (using correct BEM class name)
                const componentDiv = target.closest('.prompt-builder__component');
                const textarea = componentDiv?.querySelector('.component-textarea');
                
                if (!textarea) {
                    console.error('Could not find textarea for component:', componentType);
                    return;
                }
                
                if (selectedValue === 'custom') {
                    // User wants to write their own
                    textarea.value = '';
                    textarea.focus();
                    console.log(`‚úèÔ∏è Switched to custom input for ${componentType}`);
                } else if (selectedValue === '') {
                    // User selected default "Select a prompt..." option
                    textarea.value = '';
                    console.log(`üîÑ Cleared ${componentType} selection`);
                } else {
                    // User selected a predefined prompt
                    const selectedComponent = appState.cache.components.find(c => 
                        c.type_key === componentType && c.selection === selectedValue
                    );
                    
                    if (selectedComponent && selectedComponent.prompt_value) {
                        textarea.value = selectedComponent.prompt_value;
                        console.log(`üìù Loaded predefined prompt for ${componentType}: ${selectedValue}`);
                    } else {
                        console.warn(`‚ö†Ô∏è No prompt value found for ${componentType}: ${selectedValue}`);
                        textarea.value = '';
                    }
                }
                
                // Update appState to track the selection
                if (!appState.activeProject) appState.activeProject = {};
                if (!appState.activeProject.builder) appState.activeProject.builder = {};
                if (!appState.activeProject.builder[componentType]) {
                    appState.activeProject.builder[componentType] = {};
                }
                
                appState.activeProject.builder[componentType].selection = selectedValue;
                appState.activeProject.builder[componentType].promptValue = textarea.value;
                
                console.log(`üíæ Updated appState for ${componentType}:`, appState.activeProject.builder[componentType]);
            }

            function handleAssembleAll(target, event) {
                console.log('üîß Assemble all components requested');
                assembleAllComponents();
            }

            function assembleAllComponents() {
                try {
                    console.log('üîÑ Assembling all components into final prompt...');
                    
                    // Find all component textareas with content
                    const componentTextareas = document.querySelectorAll('.prompt-builder__component .component-textarea');
                    const componentParts = [];
                    
                    componentTextareas.forEach(textarea => {
                        const content = textarea.value.trim();
                        if (content) {
                            // Get the component type for labeling
                            const componentType = textarea.dataset.componentType;
                            const componentDiv = textarea.closest('.prompt-builder__component');
                            const componentTitle = componentDiv?.querySelector('.component__header h4')?.textContent || componentType;
                            
                            console.log(`üìù Found content for ${componentTitle}: ${content.substring(0, 50)}...`);
                            
                            // Add the component with a label
                            componentParts.push(`**${componentTitle}:**\n${content}`);
                        }
                    });
                    
                    if (componentParts.length === 0) {
                        console.warn('‚ö†Ô∏è No component content found to assemble');
                        alert('No component content found. Please select prompts or enter custom content in the components first.');
                        return;
                    }
                    
                    // Assemble the final prompt
                    const assembledPrompt = componentParts.join('\n\n');
                    console.log(`‚úÖ Assembled ${componentParts.length} components into final prompt`);
                    
                    // Find the final prompt textarea (in Refinement tab)
                    const finalPromptTextarea = document.getElementById('finalPrompt-textarea');
                    if (finalPromptTextarea) {
                        finalPromptTextarea.value = assembledPrompt;
                        console.log('üìã Final prompt updated in Refinement tab');
                        
                        // Show success feedback
                        showAssembleSuccess(componentParts.length);
                        
                        // Switch to Refinement tab to show the result
                        switchToRefinementTab();
                        
                    } else {
                        console.error('‚ùå Could not find finalPrompt-textarea element');
                        alert('Error: Could not find the Final Prompt textarea. Please check the Refinement tab.');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error assembling components:', error);
                    alert(`Error assembling components: ${error.message}`);
                }
            }

            function showAssembleSuccess(componentCount) {
                // Find the assemble button and show temporary success state
                const assembleButton = document.querySelector('[data-action="assembleAll"]');
                if (assembleButton) {
                    const originalText = assembleButton.textContent;
                    assembleButton.textContent = `‚úÖ Assembled ${componentCount} Components!`;
                    assembleButton.style.backgroundColor = 'var(--success-color)';
                    
                    // Reset after 2 seconds
                    setTimeout(() => {
                        assembleButton.textContent = originalText;
                        assembleButton.style.backgroundColor = '';
                    }, 2000);
                }
                
                console.log(`üéØ Successfully assembled ${componentCount} components into final prompt`);
            }

            // Database Admin Handlers - MIXED STATUS
            async function handleComponentActiveToggle(target, event) {
                const componentId = target.dataset.componentId;
                const isActive = target.checked;
                
                if (!componentId) {
                    console.error('No component ID found for active toggle');
                    return;
                }
                
                console.log(`üíæ Auto-saving component ${componentId} active state: ${isActive}`);
                
                try {
                    // Save to database
                    const response = await fetch(`/api/user-components/${componentId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            is_active: isActive
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Show success feedback
                    showSaveSuccess(target);
                    
                    // Update appState cache
                    updateComponentCache(componentId, { is_active: isActive });
                    
                    // Trigger surgical cross-tab update
                    triggerCrossTabRerender('database-components', 'active_state', {
                        componentId: componentId,
                        isActive: isActive
                    });
                    
                    console.log(`‚úÖ Component ${componentId} active state saved: ${isActive}`);
                    
                } catch (error) {
                    console.error(`‚ùå Error saving component ${componentId} active state:`, error);
                    showSaveError(target, error.message);
                    // Revert checkbox state on error
                    target.checked = !isActive;
                }
            }

            function handleAdminToggleDetails(target, event) {
                console.log('Admin toggle details requested');
                
                // Toggle the visibility of tier2 details area
                const componentsAdmin = document.querySelector('.collapsible-panel__inner-wrapper.components-admin');
                if (componentsAdmin) {
                    componentsAdmin.classList.toggle('show-tier2');
                    
                    // Update button text
                    const button = document.getElementById('toggle-details-btn');
                    if (button) {
                        const isShowing = componentsAdmin.classList.contains('show-tier2');
                        button.textContent = isShowing ? 'Hide Details' : 'Show Details';
                    }
                    
                    // Add/remove tier2 content area if it doesn't exist
                    let tier2Content = document.getElementById('admin-tier2-content');
                    if (!tier2Content) {
                        tier2Content = document.createElement('div');
                        tier2Content.id = 'admin-tier2-content';
                        tier2Content.className = 'tier2-col admin-tier2-content';
                        tier2Content.innerHTML = `
                            <div class="tier2-details-row">
                                <div class="tier2-details-box">
                                    <h4>Advanced Admin Settings</h4>
                                    <p>This area will contain advanced database administration tools and settings.</p>
                                    <p><em>Placeholder for future functionality:</em></p>
                                    <ul>
                                        <li>Bulk operations</li>
                                        <li>Import/Export tools</li>
                                        <li>Database optimization</li>
                                        <li>Component analytics</li>
                                    </ul>
                                </div>
                            </div>
                        `;
                        
                        // Insert at the end of the components admin area
                        const groupedView = document.getElementById('components-grouped-view');
                        if (groupedView) {
                            groupedView.appendChild(tier2Content);
                        }
                    }
                    
                    console.log('Toggled admin details visibility');
                }
            }

            async function handleComponentGroupCheckbox(target, event) {
                const promptSetId = parseInt(target.dataset.promptSetId);
                const componentTypeId = parseInt(target.dataset.componentTypeId);
                const isVisible = target.checked;
                
                if (!promptSetId || !componentTypeId) {
                    console.error('Missing prompt set ID or component type ID for visibility toggle');
                    return;
                }
                
                console.log(`üíæ Saving visibility: prompt set ${promptSetId}, component type ${componentTypeId}, visible: ${isVisible}`);
                
                try {
                    // Save to database
                    const response = await fetch('/api/prompt-set-visibility', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            promptSetId: promptSetId,
                            componentTypeId: componentTypeId,
                            isVisible: isVisible
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Update visual state immediately
                    updateVisibilityUIState(target, isVisible);
                    
                    // Update appState cache
                    updateVisibilityCache(promptSetId, componentTypeId, isVisible);
                    
                    // Show success feedback
                    showToast(`Component visibility ${isVisible ? 'enabled' : 'disabled'}`, 'success', 2000);
                    
                    // Trigger cross-tab synchronization
                    triggerCrossTabRerender('database-components', 'visibility_change', {
                        promptSetId: promptSetId,
                        componentTypeId: componentTypeId,
                        isVisible: isVisible
                    });
                    
                    console.log(`‚úÖ Visibility updated successfully: ${isVisible ? 'visible' : 'hidden'}`);
                    
                } catch (error) {
                    console.error(`‚ùå Error updating visibility:`, error);
                    
                    // Revert checkbox state on error
                    target.checked = !isVisible;
                    
                    showToast(`Failed to update visibility: ${error.message}`, 'error');
                }
            }

            async function handleRefreshAll(target, event) {
                console.log('üîÑ Refresh All requested - clearing cache and reloading data');
                
                // Clear appState cache to force fresh data load
                if (appState.cache) {
                    appState.cache.components = [];
                    appState.cache.componentTypes = [];
                    appState.cache.promptSets = [];
                    appState.cache.visibility = [];
                }
                appState.builderComponentData = {};
                
                // Refresh Database Components panel
                await initializeDatabaseComponentsFromDatabase();
                
                // Refresh Prompt Builder if visible
                const promptBuilderPanel = document.getElementById('prompt-builder-panel');
                if (promptBuilderPanel && promptBuilderPanel.style.display !== 'none') {
                    await initializePromptBuilderFromDatabase();
                }
                
                console.log('‚úÖ Refresh All completed');
                showToast('All data refreshed from database', 'success');
            }

            async function handleComponentRename(target, event) {
                // Only handle blur events for auto-save
                if (event.type !== 'blur') return;
                
                const typeKey = target.dataset.originalType;
                const newDisplayName = target.value.trim();
                
                if (!typeKey) {
                    console.error('No type key found for component rename');
                    return;
                }
                
                if (!newDisplayName) {
                    console.error('Component type name cannot be empty');
                    showSaveError(target, 'Name cannot be empty');
                    return;
                }
                
                console.log(`üíæ Auto-saving component type rename ${typeKey}: "${newDisplayName}"`);
                
                try {
                    // Save to database
                    const response = await fetch(`/api/component-types/${typeKey}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            displayName: newDisplayName
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Show success feedback
                    showSaveSuccess(target);
                    
                    // Update appState cache
                    updateComponentTypeCache(typeKey, { display_name: newDisplayName });
                    
                    // Update builderComponentData
                    updateBuilderComponentData(typeKey, newDisplayName);
                    
                    // Trigger surgical cross-tab update
                    triggerCrossTabRerender('database-components', 'component_rename', {
                        typeKey: typeKey,
                        newDisplayName: newDisplayName
                    });
                    
                    console.log(`‚úÖ Component type ${typeKey} renamed to "${newDisplayName}" successfully`);
                    
                } catch (error) {
                    console.error(`‚ùå Error renaming component type ${typeKey}:`, error);
                    showSaveError(target, error.message);
                }
            }

            // UI Interaction Handlers - MIXED STATUS
            function handlePanelToggle(target, event) {
                console.log('üîΩ Panel toggle requested');
                // REMOVAL CANDIDATE: Panel collapsing never implemented - simplified to tab-only navigation
            }

            async function handlePromptSetChange(target, event) {
                const promptSetKey = target.dataset.promptSetKey;
                
                if (!promptSetKey) {
                    console.error('No prompt set key found for prompt set change');
                    return;
                }
                
                console.log(`üéØ Switching to prompt set: ${promptSetKey}`);
                
                try {
                    // Save active prompt set to database
                    const currentUiSettings = appState.currentProjectSettings?.ui_settings || '{}';
                    const uiSettings = JSON.parse(currentUiSettings);
                    uiSettings.activePromptSet = promptSetKey;
                    
                    const response = await fetch('/api/project-settings', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            ui_settings: JSON.stringify(uiSettings)
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Update appState cache
                    appState.activePromptSet = promptSetKey;
                    if (!appState.currentProjectSettings) {
                        appState.currentProjectSettings = {};
                    }
                    appState.currentProjectSettings.ui_settings = JSON.stringify(uiSettings);
                    
                    // Update left rail visual states
                    updatePromptSetActiveState(promptSetKey);
                    
                    // Update Prompt Builder header
                    updatePromptBuilderHeader(promptSetKey);
                    
                    // Show success feedback
                    showToast(`Switched to ${getPromptSetDisplayName(promptSetKey)}`, 'success', 2000);
                    
                    // Trigger cross-tab synchronization
                    triggerCrossTabRerender('prompt-sets', 'prompt_set_change', {
                        promptSetKey: promptSetKey
                    });
                    
                    console.log(`‚úÖ Prompt set switched to: ${promptSetKey}`);
                    
                } catch (error) {
                    console.error(`‚ùå Error switching prompt set to ${promptSetKey}:`, error);
                    showToast(`Failed to switch prompt set: ${error.message}`, 'error');
                }
            }

            function handleTabSwitch(target, event) {
                // BULLETPROOF: Only handle tab buttons with proper data attributes
                if (!target.classList.contains('tab-button') || !target.dataset.tabTarget) {
                    console.log('üö´ Not a valid tab button, ignoring');
                    return;
                }
                
                const targetPanelId = target.dataset.tabTarget.replace('#', '');
                console.log('üìë INDEPENDENT Tab Switch to panel:', targetPanelId);
                switchToPanelById(targetPanelId);
                
                // Update active tab button
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                target.classList.add('active');
                
                // BULLETPROOF: Prevent any interference with other event systems
                event.preventDefault();
                event.stopImmediatePropagation();
            }

            function switchToPanelById(panelId) {
                try {
                    console.log(`üéØ Switching to panel: ${panelId}`);
                    
                    // Hide all tab contents using display style
                    const allTabContents = document.querySelectorAll('.tab-content');
                    allTabContents.forEach(content => {
                        content.style.display = 'none';
                        content.classList.remove('active');
                    });
                    
                    // Show the target tab content
                    const targetContent = document.getElementById(panelId);
                    if (targetContent) {
                        targetContent.style.display = 'block';
                        targetContent.classList.add('active');
                        console.log(`‚úÖ Activated panel: ${panelId}`);
                        
                        // Cross-tab sync check - refresh target panel if needed
                        if (panelId === 'prompt-builder-panel') {
                            console.log('üîÑ Refreshing Prompt Builder for potential visibility changes');
                            initializePromptBuilderFromDatabase();
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è Could not find panel: ${panelId}`);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error switching panels:', error);
                }
            }

            // Legacy function for backward compatibility
            function switchToTab(tabName) {
                // Map old tab names to panel IDs for backward compatibility
                const tabMapping = {
                    'prompt-builder': 'prompt-builder-panel',
                    'refinement': 'refinement-panel', 
                    'text-transformer': 'text-transformer-panel',
                    'article-workspace': 'article-workspace-panel',
                    'database-components': 'database-components-panel'
                };
                
                const panelId = tabMapping[tabName] || `${tabName}-panel`;
                switchToPanelById(panelId);
            }

            // Helper function to switch to Refinement tab after assembly
            function switchToRefinementTab() {
                switchToTab('refinement');
            }

            // Input Handlers - FUTURE FEATURES
            function handleProjectTitleInput(target, event) {
                console.log('Project title input changed:', target.value);
                // FUTURE FEATURE: Auto-save project title on input - currently manual save only
            }

            function handleContentBlockInput(target, event) {
                console.log('Content block input changed');
                // REMOVAL CANDIDATE: Content blocks never implemented - functionality moved to components
            }

            async function handleComponentInput(target, event) {
                // Only handle blur events for auto-save
                if (event.type !== 'blur') return;
                
                const componentId = target.dataset.componentId;
                const newValue = target.value;
                
                if (!componentId) {
                    console.error('No component ID found for textarea');
                    return;
                }
                
                console.log(`üíæ Auto-saving component ${componentId}: "${newValue.substring(0, 50)}${newValue.length > 50 ? '...' : ''}"`);
                
                try {
                    // Save to database
                    const response = await fetch(`/api/user-components/${componentId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt_value: newValue
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Show success feedback
                    showSaveSuccess(target);
                    
                    // Update appState cache
                    updateComponentCache(componentId, { prompt_value: newValue });
                    
                    // Trigger surgical cross-tab update
                    triggerCrossTabRerender('database-components', 'prompt_value', {
                        componentId: componentId,
                        newValue: newValue
                    });
                    
                    console.log(`‚úÖ Component ${componentId} saved successfully`);
                    
                } catch (error) {
                    console.error(`‚ùå Error saving component ${componentId}:`, error);
                    showSaveError(target, error.message);
                }
            }
            
            // === TOAST NOTIFICATION SYSTEM ===
            function showToast(message, type = 'success', duration = 3000) {
                const container = document.getElementById('toast-container');
                
                // Create toast element
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                
                // Add to container
                container.appendChild(toast);
                
                // Trigger animation
                setTimeout(() => toast.classList.add('show'), 10);
                
                // Remove after duration
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (container.contains(toast)) {
                            container.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }
            
            function showSaveSuccess(element) {
                showToast('Saved successfully', 'success');
            }
            
            function showSaveError(element, errorMessage) {
                showToast(`Save failed: ${errorMessage}`, 'error');
            }
            
            function updateComponentCache(componentId, updates) {
                // Update the component in appState cache
                if (appState.cache && appState.cache.components) {
                    const component = appState.cache.components.find(c => c.id == componentId);
                    if (component) {
                        Object.assign(component, updates);
                        console.log(`üîÑ Updated component ${componentId} in cache`);
                    }
                }
            }
            
            function updateComponentTypeCache(typeKey, updates) {
                // Update the component type in appState cache
                if (appState.cache && appState.cache.componentTypes) {
                    const componentType = appState.cache.componentTypes.find(ct => ct.type_key === typeKey);
                    if (componentType) {
                        Object.assign(componentType, updates);
                        console.log(`üîÑ Updated component type ${typeKey} in cache`);
                    }
                }
            }
            
            function updateBuilderComponentData(typeKey, newDisplayName) {
                // Update the builderComponentData structure
                if (appState.builderComponentData && appState.builderComponentData[typeKey]) {
                    appState.builderComponentData[typeKey].title = newDisplayName;
                    console.log(`üîÑ Updated builderComponentData for ${typeKey}: "${newDisplayName}"`);
                }
            }
            
            // === SURGICAL UPDATE FUNCTIONS ===
            
            function updatePromptBuilderTextarea(componentId, newValue) {
                // Find the specific textarea and update its value
                const component = appState.cache.components.find(c => c.id == componentId);
                if (!component) return;
                
                const componentDiv = document.querySelector(`[data-component-type="${component.type_key}"]`);
                if (!componentDiv) return;
                
                const textarea = componentDiv.querySelector('.component-textarea');
                if (textarea && textarea.value !== newValue) {
                    textarea.value = newValue;
                    console.log(`üéØ Surgically updated textarea for component ${componentId}`);
                }
            }
            
            function updateComponentDropdownOptions(typeKey) {
                // Find the component and update its dropdown options
                const componentDiv = document.querySelector(`[data-component-type="${typeKey}"]`);
                if (!componentDiv) return;
                
                const select = componentDiv.querySelector('.component-select');
                if (!select) return;
                
                // Get current selection to preserve it
                const currentValue = select.value;
                
                // Rebuild options from cache (active components only)
                const typeComponents = appState.cache.components.filter(c => c.type_key === typeKey && c.is_active);
                
                // Clear existing options except default and custom
                select.innerHTML = '';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Select a prompt...';
                select.appendChild(defaultOption);
                
                // Add options from components
                const uniqueSelections = new Set();
                typeComponents.forEach(component => {
                    if (component.selection && !uniqueSelections.has(component.selection)) {
                        uniqueSelections.add(component.selection);
                        const option = document.createElement('option');
                        option.value = component.selection;
                        option.textContent = component.selection;
                        select.appendChild(option);
                    }
                });
                
                // Add "Write My Own..." option
                const customOption = document.createElement('option');
                customOption.value = 'custom';
                customOption.textContent = 'Write My Own...';
                select.appendChild(customOption);
                
                // Restore previous selection if it still exists
                if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
                    select.value = currentValue;
                }
                
                console.log(`üéØ Surgically updated dropdown options for ${typeKey}`);
            }
            
            function updatePromptBuilderComponentTitle(typeKey, newDisplayName) {
                // Find the component and update its title
                const componentDiv = document.querySelector(`[data-component-type="${typeKey}"]`);
                if (!componentDiv) return;
                
                const titleElement = componentDiv.querySelector('.component-title');
                if (titleElement && titleElement.textContent !== newDisplayName) {
                    titleElement.textContent = newDisplayName;
                    console.log(`üéØ Surgically updated title for ${typeKey}: "${newDisplayName}"`);
                }
                
                // Also update textarea placeholder
                const textarea = componentDiv.querySelector('.component-textarea');
                if (textarea) {
                    textarea.placeholder = `Enter your ${newDisplayName.toLowerCase()} prompt...`;
                }
            }
            
            function updatePromptBuilderActiveState(componentId, isActive) {
                // Find the component and its type
                const component = appState.cache.components.find(c => c.id == componentId);
                if (!component) return;
                
                // Update the dropdown options for this component type to reflect active state
                updateComponentDropdownOptions(component.type_key);
                
                console.log(`üéØ Surgically updated active state for component ${componentId}: ${isActive}`);
            }
            
            async function handleAdminSelectionBlur(target, event) {
                // Only handle blur events for auto-save
                if (event.type !== 'blur') return;
                
                const componentId = target.dataset.componentId;
                const newValue = target.value.trim();
                
                if (!componentId) {
                    console.error('No component ID found for selection input');
                    return;
                }
                
                console.log(`üíæ Auto-saving selection ${componentId}: "${newValue}"`);
                
                try {
                    // Save to database
                    const response = await fetch(`/api/user-components/${componentId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            selection: newValue
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    // Show success feedback
                    showSaveSuccess(target);
                    
                    // Update appState cache
                    updateComponentCache(componentId, { selection: newValue });
                    
                    // Refresh Prompt Builder dropdowns since selection names changed
                    refreshPromptBuilderDropdowns();
                    
                    // Trigger surgical cross-tab update
                    const component = appState.cache.components.find(c => c.id == componentId);
                    if (component) {
                        triggerCrossTabRerender('database-components', 'selection', {
                            typeKey: component.type_key
                        });
                    }
                    
                    console.log(`‚úÖ Selection ${componentId} saved successfully`);
                    
                } catch (error) {
                    console.error(`‚ùå Error saving selection ${componentId}:`, error);
                    showSaveError(target, error.message);
                }
            }
            
            function refreshPromptBuilderDropdowns() {
                // Surgical update: refresh only the dropdowns without full rebuild
                console.log('üîÑ Surgically updating Prompt Builder dropdowns for selection name changes');
                
                const promptBuilderPanel = document.getElementById('prompt-builder-panel');
                if (!promptBuilderPanel) return;
                
                // Update each component type's dropdown options
                if (appState.cache && appState.cache.componentTypes) {
                    appState.cache.componentTypes.forEach(type => {
                        updateComponentDropdownOptions(type.type_key);
                    });
                }
            }
            

            
            function triggerCrossTabRerender(panelType, updateType, data) {
                // Surgical DOM updates for cross-tab synchronization
                console.log(`üîÑ Triggering surgical cross-tab update: ${updateType || 'general'}`);
                
                // Handle specific update types surgically
                if (updateType === 'prompt_value' && data) {
                    updatePromptBuilderTextarea(data.componentId, data.newValue);
                } else if (updateType === 'selection' && data) {
                    updateComponentDropdownOptions(data.typeKey);
                } else if (updateType === 'component_rename' && data) {
                    updatePromptBuilderComponentTitle(data.typeKey, data.newDisplayName);
                } else if (updateType === 'active_state' && data) {
                    updatePromptBuilderActiveState(data.componentId, data.isActive);
                } else if (updateType === 'prompt_set_change' && data) {
                    updateCrossTabPromptSetChange(data.promptSetKey);
                } else if (updateType === 'visibility_change' && data) {
                    updateCrossTabVisibilityChange(data.promptSetId, data.componentTypeId, data.isVisible);
                } else {
                    // Fallback: refresh admin panel if visible (existing behavior)
                    const adminPanel = document.getElementById('database-components-panel');
                    if (adminPanel && adminPanel.style.display !== 'none') {
                        console.log(`üîÑ Refreshing ${panelType} panel for cross-tab sync`);
                        initializeDatabaseComponentsFromDatabase();
                    }
                }
            }
            
            function updateCrossTabPromptSetChange(promptSetKey) {
                // Update left rail active states
                updatePromptSetActiveState(promptSetKey);
                
                // Update Prompt Builder header
                updatePromptBuilderHeader(promptSetKey);
                
                // Rebuild Prompt Builder with new visibility rules for the active prompt set
                updatePromptBuilderForPromptSetChange(promptSetKey);
                
                console.log(`üéØ Cross-tab prompt set update: ${promptSetKey}`);
            }
            
            function updatePromptBuilderForPromptSetChange(promptSetKey) {
                const promptBuilderPanel = document.getElementById('prompt-builder-panel');
                if (!promptBuilderPanel || promptBuilderPanel.style.display === 'none') {
                    console.log('üîç Prompt Builder not visible, skipping component filtering update');
                    return;
                }
                
                const palletContainer = document.getElementById('prompt-builder-pallet');
                if (!palletContainer) {
                    console.warn('‚ö†Ô∏è Prompt Builder pallet container not found');
                    return;
                }
                
                // Check if we have the necessary data in cache
                if (!appState.cache || !appState.cache.componentTypes || !appState.cache.promptSets || !appState.cache.visibility) {
                    console.log('üîÑ Cache data incomplete, performing full Prompt Builder refresh');
                    initializePromptBuilderFromDatabase();
                    return;
                }
                
                // Clear current components
                palletContainer.innerHTML = '';
                
                // Get visible component types for the new active prompt set
                const visibleTypes = getVisibleComponentTypes(
                    appState.cache.componentTypes, 
                    appState.cache.promptSets, 
                    appState.cache.visibility, 
                    promptSetKey
                );
                
                if (visibleTypes.length > 0) {
                    visibleTypes.forEach((type, index) => {
                        console.log(`üß© Adding component for prompt set change: ${type.display_name} (${type.type_key})`);
                        createPromptBuilderComponent(palletContainer, type, appState.cache.components, index);
                    });
                    
                    console.log(`‚úÖ Rebuilt Prompt Builder with ${visibleTypes.length} visible components for "${promptSetKey}"`);
                } else {
                    // Show empty state
                    palletContainer.innerHTML = `
                        <div class="prompt-builder__no-components">
                            <h4>No Components Available</h4>
                            <p>No components are visible for the "${getPromptSetDisplayName(promptSetKey)}" prompt set.</p>
                            <p>Go to the <strong>Database Components</strong> panel to enable component visibility.</p>
                        </div>
                    `;
                    console.log(`‚ö†Ô∏è No components visible for prompt set: ${promptSetKey}`);
                }
            }
            
            function updateCrossTabVisibilityChange(promptSetId, componentTypeId, isVisible) {
                // Update the checkbox and status in Database Components panel (if visible)
                const adminPanel = document.getElementById('database-components-panel');
                if (adminPanel && adminPanel.style.display !== 'none') {
                    const checkbox = adminPanel.querySelector(
                        `input[data-prompt-set-id="${promptSetId}"][data-component-type-id="${componentTypeId}"]`
                    );
                    if (checkbox && checkbox.checked !== isVisible) {
                        checkbox.checked = isVisible;
                        updateVisibilityUIState(checkbox, isVisible);
                    }
                }
                
                // Update Prompt Builder if visible - full pallet refresh like prompt set switching
                const promptBuilderPanel = document.getElementById('prompt-builder-panel');
                if (promptBuilderPanel && promptBuilderPanel.style.display !== 'none') {
                    console.log('üîÑ Refreshing Prompt Builder pallet for visibility change');
                    initializePromptBuilderFromDatabase();
                }
                
                console.log(`üëÅÔ∏è Cross-tab visibility update: prompt set ${promptSetId}, component type ${componentTypeId}, visible: ${isVisible}`);
            }
            
            function updatePromptBuilderForVisibilityChange(promptSetId, componentTypeId, isVisible) {
                // Only update if this visibility change affects the currently active prompt set
                const activePromptSet = appState.activePromptSet || 'custom_build';
                const activePromptSetData = appState.cache?.promptSets?.find(ps => ps.set_key === activePromptSet);
                
                if (!activePromptSetData || activePromptSetData.id !== promptSetId) {
                    console.log(`üîç Visibility change doesn't affect active prompt set "${activePromptSet}", skipping Prompt Builder update`);
                    return;
                }
                
                // Find the affected component type
                const componentType = appState.cache?.componentTypes?.find(ct => ct.id === componentTypeId);
                if (!componentType) {
                    console.warn(`‚ö†Ô∏è Component type ${componentTypeId} not found in cache`);
                    return;
                }
                
                const promptBuilderPanel = document.getElementById('prompt-builder-panel');
                if (!promptBuilderPanel || promptBuilderPanel.style.display === 'none') {
                    console.log('üîç Prompt Builder not visible, skipping update');
                    return;
                }
                
                const palletContainer = document.getElementById('prompt-builder-pallet');
                if (!palletContainer) {
                    console.warn('‚ö†Ô∏è Prompt Builder pallet container not found');
                    return;
                }
                
                // Find existing component in Prompt Builder
                const existingComponent = palletContainer.querySelector(`[data-component-type="${componentType.type_key}"]`);
                
                if (isVisible && !existingComponent) {
                    // Component should be visible but doesn't exist - add it
                    console.log(`‚ûï Adding component "${componentType.display_name}" to Prompt Builder`);
                    createPromptBuilderComponent(palletContainer, componentType, appState.cache.components, 0);
                } else if (!isVisible && existingComponent) {
                    // Component should be hidden but exists - remove it
                    console.log(`‚ûñ Removing component "${componentType.display_name}" from Prompt Builder`);
                    existingComponent.remove();
                } else {
                    console.log(`üîç No Prompt Builder update needed for "${componentType.display_name}"`);
                }
                
                // Check if no components are visible and show appropriate message
                updatePromptBuilderEmptyState();
            }
            
            function updatePromptBuilderEmptyState() {
                const palletContainer = document.getElementById('prompt-builder-pallet');
                if (!palletContainer) return;
                
                const components = palletContainer.querySelectorAll('.prompt-builder__component');
                const emptyState = palletContainer.querySelector('.prompt-builder__no-components');
                
                if (components.length === 0 && !emptyState) {
                    // No components visible, show empty state
                    const activePromptSet = appState.activePromptSet || 'custom_build';
                    palletContainer.innerHTML = `
                        <div class="prompt-builder__no-components">
                            <h4>No Components Available</h4>
                            <p>No components are visible for the "${getPromptSetDisplayName(activePromptSet)}" prompt set.</p>
                            <p>Go to the <strong>Database Components</strong> panel to enable component visibility.</p>
                        </div>
                    `;
                } else if (components.length > 0 && emptyState) {
                    // Components are visible, remove empty state
                    emptyState.remove();
                }
            }

            // --- INDEPENDENT EVENT DELEGATION SYSTEM ---
            // Each functional area has its own independent event handler
            // This prevents interference between different parts of the app

            function setupAppEventListeners() {
                const appContainer = document.querySelector('.app-container');
                
                // === PROJECT MANAGEMENT EVENTS (Independent) ===
                appContainer.addEventListener('click', handleProjectEvents);
                
                // === PROMPT BUILDER EVENTS (Independent) ===
                appContainer.addEventListener('change', handlePromptBuilderEvents);
                appContainer.addEventListener('click', handlePromptBuilderClickEvents);
                
                // === TAB NAVIGATION EVENTS (Independent) ===
                appContainer.addEventListener('click', handleTabNavigationEvents);
                
                // === CONTENT MANAGEMENT EVENTS (Independent) ===
                appContainer.addEventListener('click', handleContentEvents);
                
                // === ADMIN PANEL EVENTS (Independent) ===
                appContainer.addEventListener('change', handleAdminEvents);
                appContainer.addEventListener('click', handleAdminClickEvents);
                
                // === TEXT TRANSFORMER EVENTS (Independent) ===
                appContainer.addEventListener('click', handleTextTransformerEvents);
                
                // === INPUT EVENTS (Independent) ===
                appContainer.addEventListener('input', handleInputEvents);
                appContainer.addEventListener('blur', handleInputEvents, true); // Use capture for blur events
            }

            // === PROJECT MANAGEMENT EVENT HANDLER ===
            function handleProjectEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle project-related actions
                const projectActions = ['saveProject', 'saveAsProject', 'loadProject', 'deleteCurrentProject', 'createProject', 'adminReset', 'changePromptSet'];
                if (!projectActions.includes(action)) return;
                
                console.log(`üèóÔ∏è Project Event: ${action}`);
                
                switch (action) {
                    case 'saveProject': handleProjectSave(target, event); break;
                    case 'saveAsProject': handleProjectSaveAs(target, event); break;
                    case 'loadProject': handleProjectLoad(target, event); break;
                    case 'deleteCurrentProject': handleDeleteCurrentProject(target, event); break;
                    case 'createProject': createNewProject(target, event); break;
                    case 'adminReset': handleAdminReset(target, event); break;
                    case 'changePromptSet': handlePromptSetChange(target, event); break;
                }
                
                event.stopPropagation(); // Prevent interference with other handlers
            }

            // === PROMPT BUILDER EVENT HANDLERS ===
            function handlePromptBuilderEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle prompt builder change events
                if (action !== 'componentSelect') return;
                
                console.log(`üß© Prompt Builder Change Event: ${action}`);
                handleComponentSelect(target, event);
                event.stopPropagation();
            }

            function handlePromptBuilderClickEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle prompt builder click events
                const builderActions = ['addComponent', 'removeComponent', 'assembleAll'];
                if (!builderActions.includes(action)) return;
                
                console.log(`üß© Prompt Builder Click Event: ${action}`);
                
                switch (action) {
                    case 'addComponent': handleAddComponent(target, event); break;
                    case 'removeComponent': handleRemoveComponent(target, event); break;
                    case 'assembleAll': handleAssembleAll(target, event); break;
                }
                
                event.stopPropagation();
            }

            // === TAB NAVIGATION EVENT HANDLER ===
            function handleTabNavigationEvents(event) {
                const target = event.target;
                
                // BULLETPROOF: Only handle actual navigation tab buttons with switchTab action
                const isNavigationTab = target.classList.contains('tab-button') &&
                                       target.dataset.action === 'switchTab' &&
                                       !target.classList.contains('component__select') &&
                                       !target.closest('.component__controls');
                
                if (!isNavigationTab) return;
                
                console.log(`üìë INDEPENDENT Tab Navigation Event Detected`);
                handleTabSwitch(target, event);
                event.stopPropagation();
            }

            // === CONTENT MANAGEMENT EVENT HANDLER ===
            function handleContentEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle content-related actions
                const contentActions = ['draftSave', 'draftDelete', 'draftSelect', 'insertOutline', 'copyToClipboard', 'clearContent', 'switchTab'];
                if (!contentActions.includes(action)) return;
                
                console.log(`üìù Content Event: ${action}`);
                
                switch (action) {
                    case 'draftSave': handleDraftSave(target, event); break;
                    case 'draftDelete': handleDraftDelete(target, event); break;
                    case 'draftSelect': handleDraftSelect(target, event); break;
                    case 'insertOutline': handleInsertOutline(target, event); break;
                    case 'copyToClipboard': handleCopyToClipboard(target, event); break;
                    case 'clearContent': handleClearContent(target, event); break;
                    case 'switchTab': handleTabSwitch(target, event); break;
                }
                
                event.stopPropagation();
            }

            // === ADMIN PANEL EVENT HANDLERS ===
            function handleAdminEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle admin change events
                const adminChangeActions = ['componentGroupCheckbox', 'componentRename'];
                if (!adminChangeActions.includes(action)) return;
                
                console.log(`‚öôÔ∏è Admin Change Event: ${action}`);
                
                switch (action) {
                    case 'componentGroupCheckbox': handleComponentGroupCheckbox(target, event); break;
                    case 'componentRename': handleComponentRename(target, event); break;
                }
                
                event.stopPropagation();
            }

            function handleAdminClickEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle admin click events
                const adminClickActions = ['componentActiveToggle', 'toggleAdminDetails', 'refreshAll'];
                if (!adminClickActions.includes(action)) return;
                
                console.log(`‚öôÔ∏è Admin Click Event: ${action}`);
                
                switch (action) {
                    case 'componentActiveToggle': handleComponentActiveToggle(target, event); break;
                    case 'toggleAdminDetails': handleAdminToggleDetails(target, event); break;
                    case 'refreshAll': handleRefreshAll(target, event); break;
                }
                
                event.stopPropagation();
            }

            // === TEXT TRANSFORMER EVENT HANDLER ===
            function handleTextTransformerEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Only handle text transformer events
                const transformerActions = ['selectTextTransformerAction', 'selectTextTransformerOption', 'executeTextTransform', 'copyUp'];
                if (!transformerActions.includes(action)) return;
                
                console.log(`üîÑ Text Transformer Event: ${action}`);
                
                switch (action) {
                    case 'selectTextTransformerAction': handleTextTransformerAction(target, event); break;
                    case 'selectTextTransformerOption': handleTextTransformerOption(target, event); break;
                    case 'executeTextTransform': handleTextTransformExecute(target, event); break;
                    case 'copyUp': handleTextCopyUp(target, event); break;
                }
                
                event.stopPropagation();
            }

            // === INPUT EVENT HANDLER ===
            function handleInputEvents(event) {
                const target = event.target;
                const action = target.dataset.action;
                
                // Handle both input and blur events
                const inputActions = ['projectTitleInput', 'contentBlockInput', 'componentInput', 'adminSelectionBlur', 'componentRename'];
                if (!inputActions.includes(action)) return;
                
                console.log(`‚å®Ô∏è Input Event: ${action} (${event.type})`);
                
                switch (action) {
                    case 'projectTitleInput': handleProjectTitleInput(target, event); break;
                    case 'contentBlockInput': handleContentBlockInput(target, event); break;
                    case 'componentInput': handleComponentInput(target, event); break;
                    case 'adminSelectionBlur': handleAdminSelectionBlur(target, event); break;
                    case 'componentRename': handleComponentRename(target, event); break;
                }
                
                // Only stop propagation for events we actually handled
                event.stopPropagation();
            }

            // --- ELIMINATED: fetchAndInitializeData function removed ---
            // Replaced with direct database-to-DOM initialization system

            function updateComponentState(key, newState) {
                const componentState = appState.activeProject.builder[key];
                const componentData = builderComponentData[key];
                if (!componentState) return;

                // Update the selection state
                Object.assign(componentState, newState);

                if (newState.selection === 'custom') {
                    // If user selects "Write My Own...", restore their saved text.
                    componentState.promptValue = componentState.userValue;
                } else {
                    // If user selects a pre-defined prompt, load it.
                    if (componentData && componentData.prompts) {
                        componentState.promptValue = componentData.prompts[newState.selection] || '';
                    }
                }
            }

            // Generic checkbox handler for all checkbox interactions
            function handleCheckboxChange(checkboxPath, value) {
                // This robustly navigates the path, creating nested objects if they don't exist.
                let target = appState;
                for (let i = 0; i < checkboxPath.length - 1; i++) {
                    const segment = checkboxPath[i];
                    if (target[segment] === undefined) {
                        // Create the missing object if it doesn't exist.
                        target[segment] = {};
                    }
                    target = target[segment];
                }

                // Set the final property
                const finalKey = checkboxPath[checkboxPath.length - 1];
                target[finalKey] = value;
                
                // Check if this change affects the current prompt set
                if (checkboxPath[0] === 'activeProject' && checkboxPath[1] === 'promptSets') {
                    const promptSetKey = checkboxPath[2];
                    const componentType = checkboxPath[3];
                    
                    // If this is the current active prompt set, update the builder
                    if (promptSetKey === appState.activeProject.activePromptSet) {
                        // For Custom Build, ensure the component exists in the builder
                        if (!appState.activeProject.builder[componentType]) {
                            appState.activeProject.builder[componentType] = { active: true, selection: 'custom', promptValue: '', userValue: '' };
                        }
                        appState.activeProject.builder[componentType].active = value;
                    }
                }
                
                // ELIMINATED: render() call removed
                // Targeted updates will be implemented as needed
            }

            // Function to update component type references in appState when renaming
            async             function handleComponentTypeRename(oldType, newType) {
                console.log('=== RENAME DEBUG ===');
                console.log('Renaming from:', oldType, 'to:', newType);
                console.log('Before update - builderComponentData:', builderComponentData);
                
                try {
                    updateComponentTypeInAppState(oldType, newType);
                    console.log('After update - builderComponentData:', builderComponentData);
                    
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.dataset.originalType = newType;
                    }
                    
                    // ELIMINATED: render() and renderComponentsAdmin() calls removed
                    console.log('Component rename completed - targeted updates will be implemented');
                    console.log('=== END RENAME DEBUG ===');
                    
                } catch (error) {
                    console.error('Error renaming component:', error);
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.value = oldType;
                    }
                }
            }

            function updateComponentTypeInAppState(oldName, newName) {
                console.log(`Updating component type from "${oldName}" to "${newName}" in appState`);
                
                // Update builder references
                if (appState.activeProject.builder[oldName]) {
                    appState.activeProject.builder[newName] = appState.activeProject.builder[oldName];
                    delete appState.activeProject.builder[oldName];
                }
                
                // Update promptActiveStates references
                if (appState.activeProject.promptActiveStates[oldName]) {
                    appState.activeProject.promptActiveStates[newName] = appState.activeProject.promptActiveStates[oldName];
                    delete appState.activeProject.promptActiveStates[oldName];
                }
                
                // Update promptSets references
                Object.keys(appState.activeProject.promptSets).forEach(promptSetKey => {
                    const promptSet = appState.activeProject.promptSets[promptSetKey];
                    if (promptSet[oldName]) {
                        promptSet[newName] = promptSet[oldName];
                        delete promptSet[oldName];
                    }
                });
                
                // Update builderComponentData references
                if (builderComponentData[oldName]) {
                    builderComponentData[newName] = builderComponentData[oldName];
                    builderComponentData[newName].title = newName.charAt(0).toUpperCase() + newName.slice(1);
                    delete builderComponentData[oldName];
                }
                
                console.log('appState updated successfully');
            }

            // --- COMPONENTS ADMIN FUNCTIONALITY ---
            // ELIMINATED: renderComponentsAdmin function removed
            // Admin panel will be initialized directly from database

            // --- INITIALIZATION ---
            setupUIEventListeners();
            setupAppEventListeners(); // Attach main app event listeners
            
            // Initialize all tabs directly from database (RENDER SYSTEM ELIMINATED)
            initializeAllTabsFromDatabase();

            // --- STATE MANAGEMENT HELPERS ---
            function clearUnsavedChanges() {
                appState.unsavedChanges = false;
                appState.tempInput = {
                    projectName: appState.currentProjectName || '',
                    componentContent: {},
                    contentBlocks: {}
                };
                console.log('üßπ Unsaved changes cleared');
            }
            
            function markUnsavedChanges() {
                appState.unsavedChanges = true;
                console.log('üìù Marked unsaved changes');
            }
            
            async function loadProjects() {
                try {
                    const response = await fetch('/api/projects');
                    if (!response.ok) {
                        throw new Error(`Failed to load projects: ${response.statusText}`);
                    }
                    
                    const responseData = await response.json();
                    const projects = responseData.projects || responseData; // Handle both response formats
                    appState.projects = projects;
                    appState.availableProjects = projects; // Backward compatibility
                    
                    // Update project selector UI if it exists
                    updateProjectSelector();
                    
                    console.log(`üìÅ Loaded ${projects?.length || 0} projects:`, projects);
                    return projects;
                    
                } catch (error) {
                    console.error('‚ùå Error loading projects:', error);
                    throw error;
                }
            }
            
            function updateProjectSelector() {
                const selector = document.getElementById('project-selector');
                if (!selector || !appState.projects) return;
                
                selector.innerHTML = '';
                appState.projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.id;
                    option.textContent = project.name;
                    option.selected = project.id === appState.currentProjectId;
                    selector.appendChild(option);
                });
            }
        });
    </script>


</body>
</html>