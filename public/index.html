<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompt Generator - V2</title>
    <link rel="stylesheet" href="/styles/main.css">
</head>
<body>

    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar__header">
                <span class="sidebar__hamburger" id="hamburger-button">&#9776;</span>
                <h2>Prompt Gen</h2>
            </div>
            <div class="sidebar__content">
                <h4 class="sidebar__sub-heading">Projects</h4>
                <ul id="library-list" class="sidebar__list">
                </ul>

                <h4 class="sidebar__sub-heading">Prompt Sets</h4>
                <div id="prompt-sets-list" class="sidebar__list">
                </div>

                <h4 class="sidebar__sub-heading">Settings</h4>
                <div class="sidebar__settings-container">
                    <span class="sidebar__sub-heading">Theme</span>
                    <button id="theme-light-button" class="button--utility button--theme">‚òÄÔ∏è</button>
                    <button id="theme-dark-button" class="button--utility button--theme hidden">üåô</button>
                    <div class="sidebar__database-controls">
                        <span class="sidebar__sub-heading">Database Tools</span>
                        <button id="toggle-database-section" class="button--utility">Database</button>
                    </div>
                </div>
            </div>
            <div class="sidebar__footer">
                <button id="admin-reset-button">Admin: Hard Reset</button>
            </div>
        </aside>

        <div class="main-content-wrapper">
            <main class="main-content">
                <section class="panel collapsible-panel" id="database-components-panel" style="display: none;">
                    <div class="panel__header">
                        <h3>Database Components</h3>
                        <div style="display: flex; gap: 10px; align-items: center; margin-right: 20px;">
                            <button id="toggle-details-btn" class="button--utility">Show Details</button>
                            <button id="save-all-btn" disabled class="button--utility">Save All</button>
                        </div>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper components-admin">
                            <div id="error-message" class="error error__message"></div>
                            <div id="components-grouped-view"></div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel" id="prompt-builder-panel">
                    <div class="panel__header">
                        <h3>Prompt Builder</h3>
                        <div class="panel__header-buttons">
                             <button id="add-component-button" class="button--utility">Add Component</button>
                        </div>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="prompt-builder__pallet" id="prompt-builder-pallet">
                                </div>
                            <div class="prompt-assembler__output">
                                <div class="generate-button-container">
                                    <button id="assemble-all-button" class="button--primary">Add All to Final Prompt</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>


                <section class="panel" id="project-hub-panel">
                    <div class="panel__header">
                       <h3>Project Hub</h3>
                       <div class="panel__header-buttons">
                           <button id="save-project-button" class="button--utility">Save</button>
                           <button id="save-as-project-button" class="button--utility">Save As...</button>
                       </div>
                   </div>
                   <input type="text" id="project-title-input" class="panel__title-input" placeholder="Enter Project Title...">
               </section>


                <section class="panel collapsible-panel" id="refinement-panel">
                     <div class="panel__header">
                        <h3>Refinement</h3>
                         <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                     <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="refinement-area">
                                <div class="panel user-outline-panel">
                                    <div class="panel__header"><h3>User Outline</h3></div>
                                    <textarea id="userOutline-textarea" autocomplete="off" placeholder="Write your outline or dump your thoughts here..."></textarea>
                                    <div class="draft-controls" data-content-block="userOutline"><select class="draft-controls__select"></select><button class="draft-controls__button--save">Save</button><button class="draft-controls__button--delete">üóëÔ∏è</button></div>
                                </div>
                                <div class="insert-button-container">
                                    <button id="insert-button" class="button--primary" title="Insert Outline into Final Prompt">&rarr;</button>
                                </div>
                                <div class="panel final-prompt-panel">
                                    <div class="panel__header">
                                        <h3>Final Prompt</h3>
                                        <div class="panel__header-buttons">
                                            <button id="copy-button" class="button--utility">Copy</button>
                                            <button id="clear-button" class="button--utility">Clear</button>
                                        </div>
                                    </div>
                                    <textarea id="finalPrompt-textarea" autocomplete="off" placeholder="The final, combined prompt will appear here..."></textarea>
                                    <div class="draft-controls" data-content-block="finalPrompt"><select class="draft-controls__select"></select><button class="draft-controls__button--save">Save</button><button class="draft-controls__button--delete">üóëÔ∏è</button></div>
                                </div>
                            </div>
                        </div>
                     </div>
                </section>

                <section class="panel collapsible-panel" id="text-transformer-panel">
                    <div class="panel__header">
                        <h3>Text Transformer</h3>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div id="action-engine-panel-content">
                                <div class="text-transformer__area">
                                    <div class="panel">
                                        <div class="panel__header"><h3>Input</h3></div>
                                        <textarea id="textTransformerInput-textarea" autocomplete="off" placeholder="Paste text here to transform it..."></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerInput"><select class="draft-controls__select"></select><button class="draft-controls__button--save">Save</button><button class="draft-controls__button--delete">üóëÔ∏è</button></div>
                                    </div>
                                    <div class="text-transformer__actions-container">
                                        <button class="text-transformer__action-selector" data-action="summarize">Summarize</button>
                                        <button class="text-transformer__action-selector" data-action="rewrite">Rewrite</button>
                                        <button class="text-transformer__action-selector" data-action="analyze">Analyze</button>

                                        <div id="text-transformer-options-container"></div>

                                        <button id="transform-execute-button" class="button--primary">Transform</button>
                                        <hr class="text-transformer__divider">
                                        <button class="button--utility text-transformer__action-button" data-action="copy-up" title="Copy Output to Input">‚Üë</button>
                                    </div>
                                    <div class="panel">
                                        <div class="panel__header"><h3>Output</h3></div>
                                        <textarea id="textTransformerOutput-textarea" autocomplete="off" placeholder="Transformed text will appear here..."></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerOutput"><select class="draft-controls__select"></select><button class="draft-controls__button--save">Save</button><button class="draft-controls__button--delete">üóëÔ∏è</button></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel" id="article-workspace-panel">
                    <div class="panel__header">
                        <h3>Article Workspace</h3>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <textarea id="articleWorkspace-textarea" autocomplete="off" placeholder="Paste the final draft created by the LLM here..."></textarea>
                            <div class="draft-controls" data-content-block="articleWorkspace"><select class="draft-controls__select"></select><button class="draft-controls__button--save">Save</button><button class="draft-controls__button--delete">üóëÔ∏è</button></div>
                        </div>
                    </div>
                </section>

            </main>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /*
            * == AI PROMPT GENERATOR V2 - ARCHITECTURE BRIEFING ==
            *
            * GUIDING PRINCIPLES:
            * - The application is a state-driven, single-page app. All UI is rendered from the 'appState' object.
            * - The core data model is a "Project," which contains all settings and content drafts. A "Project" is represented by the 'activeProject' object within the main 'appState'.
            * - All data saving/loading (Drafts and Projects) is IN-MEMORY for this wireframe. No persistent storage is used. Reloading the page will reset everything.
            */

            // --- UI-ONLY EVENT LISTENERS ---
            function setupUIEventListeners() {
                const hamburgerButton = document.getElementById('hamburger-button');
                const sidebar = document.getElementById('sidebar');
                const lightThemeButton = document.getElementById('theme-light-button');
                const darkThemeButton = document.getElementById('theme-dark-button');
                const body = document.body;
                const dbToggleButton = document.getElementById('toggle-database-section');
                const dbPanel = document.getElementById('database-components-panel');

                if (hamburgerButton && sidebar) {
                    hamburgerButton.addEventListener('click', () => {
                        sidebar.classList.toggle('sidebar--collapsed');
                    });
                }

                if(lightThemeButton && darkThemeButton && body) {
                    lightThemeButton.addEventListener('click', () => {
                        body.classList.add('light-mode');
                        lightThemeButton.classList.add('hidden');
                        darkThemeButton.classList.remove('hidden');
                    });
                    darkThemeButton.addEventListener('click', () => {
                        body.classList.remove('light-mode');
                        darkThemeButton.classList.add('hidden');
                        lightThemeButton.classList.remove('hidden');
                    });
                }

                if (dbToggleButton && dbPanel) {
                    dbToggleButton.addEventListener('click', () => {
                        const isVisible = dbPanel.style.display !== 'none';
                        dbPanel.style.display = isVisible ? 'none' : '';
                        dbToggleButton.classList.toggle('button--primary', !isVisible);
                        dbToggleButton.classList.toggle('button--utility', isVisible);
                    });
                }
            }


            // --- DATA MODELS (CONSTANTS) ---
            // builderComponentData has been moved to the backend and is now seeded from starter-components.js into the database.
            let builderComponentData = {};

            // --- APPLICATION STATE (THE SINGLE SOURCE OF TRUTH) ---
            function getDefaultAppState() {
                const now = Date.now();
                return {
                    currentProjectId: `proj-${now}`,
                    projectName: 'Untitled Project',
                    activePromptSet: 'custom_build',
                    promptSets: {
                        blog_post: {
                            role: { active: true, selection: 'custom', promptValue: 'Act as an expert blogger and SEO specialist.', userValue: 'Act as an expert blogger and SEO specialist.' },
                            task: { active: true, selection: 'write', promptValue: 'a comprehensive and engaging blog post about [topic].', userValue: '' },
                            context: { active: false, value: '' },
                            format: { active: true, selection: 'paragraphs', promptValue: 'Placeholder: Format the output as standard paragraphs.', userValue: '' },
                            tone: { active: true, selection: 'casual', promptValue: 'Placeholder: Use a casual and friendly tone.', userValue: '' },
                            constraints: { active: true, value: 'The blog post should be at least 800 words and include a clear call to action.' }
                        }
                    },
                    builder: {
                        role: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        task: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        job: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        audiencePro: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        audienceSilly: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        format: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        tone: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        length: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        pov: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        context: { active: true, value: '' },
                        constraints: { active: true, value: ''},
                    },
                    // New: Prompt-level active states for each component type
                    promptActiveStates: {
                        role: {},
                        task: {},
                        job: {},
                        audiencePro: {},
                        audienceSilly: {},
                        format: {},
                        tone: {},
                        length: {},
                        pov: {},
                        context: {},
                        constraints: {}
                    },
                    // New: Store all components in appState
                    components: [],
                    contentBlocks: {
                        userOutline: { activeDraftId: `draft-${now+1}`, drafts: [{ id: `draft-${now+1}`, timestamp: new Date().toISOString(), content: '' }] },
                        finalPrompt: { activeDraftId: `draft-${now+2}`, drafts: [{ id: `draft-${now+2}`, timestamp: new Date().toISOString(), content: '' }] },
                        articleWorkspace: { activeDraftId: `draft-${now+3}`, drafts: [{ id: `draft-${now+3}`, timestamp: new Date().toISOString(), content: '' }] },
                        textTransformerInput: { activeDraftId: `draft-${now+4}`, drafts: [{ id: `draft-${now+4}`, timestamp: new Date().toISOString(), content: '' }] },
                        textTransformerOutput: { activeDraftId: `draft-${now+5}`, drafts: [{ id: `draft-${now+5}`, timestamp: new Date().toISOString(), content: '' }] }
                    },
                    textTransformer: {
                        activeAction: 'analyze',
                        actions: {
                            summarize: {},
                            rewrite: {
                                activeOption: 'casual',
                                options: {
                                    professional: 'Rewrite in a professional tone.',
                                    casual: 'Rewrite in a casual tone.',
                                    empathetic: 'Rewrite with more empathy.'
                                }
                            },
                            analyze: {
                                activeOption: 'proofread',
                                options: {
                                    proofread: 'Proofread for grammar & spelling.',
                                    identify_themes: 'Identify the main themes.',
                                    fact_check: 'Fact-check for accuracy.'
                                }
                            }
                        }
                    }
                };
            }

            let appState = {
                savedProjects: [],
                activeProject: getDefaultAppState()
            };

            // --- RENDER FUNCTIONS ---
            function render() {
                const project = appState.activeProject;
                renderPromptSets(project.activePromptSet);
                renderProjectHub(project);
                renderBuilderPallet(project.builder);
                renderContentBlocks(project.contentBlocks);
                renderLibrary();
                renderTextTransformer(project.textTransformer);
            }

            function renderPromptSets(activePromptSetKey) {
                const promptSetSelectors = document.querySelectorAll('.prompt-set-selector');
                promptSetSelectors.forEach(selector => {
                    selector.classList.toggle('active', selector.dataset.promptSetKey === activePromptSetKey);
                });
            }

            function renderLibrary() {
                const libraryList = document.getElementById('library-list');
                if (!libraryList) return;
                libraryList.innerHTML = '';

                let foundActive = false;
                appState.savedProjects.forEach(project => {
                    const li = document.createElement('li');
                    if (project.currentProjectId === appState.activeProject.currentProjectId) {
                        li.className = 'active';
                        foundActive = true;
                    }

                    const textSpan = document.createElement('span');
                    textSpan.textContent = project.projectName;
                    textSpan.style.flexGrow = '1';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'sidebar__project-delete-button';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.dataset.projectId = project.currentProjectId;

                    li.appendChild(textSpan);
                    li.appendChild(deleteBtn);
                    li.dataset.projectId = project.currentProjectId;
                    libraryList.appendChild(li);
                });

                // If the active project is not in savedProjects, show it at the end with '(Unsaved)'
                if (!foundActive && appState.activeProject) {
                    const li = document.createElement('li');
                    li.className = 'active';
                    const textSpan = document.createElement('span');
                    textSpan.textContent = appState.activeProject.projectName + ' (Unsaved)';
                    textSpan.style.flexGrow = '1';
                    li.appendChild(textSpan);
                    li.dataset.projectId = appState.activeProject.currentProjectId;
                    libraryList.appendChild(li);
                }
            }

            function renderProjectHub(project) {
                const projectTitleInput = document.getElementById('project-title-input');
                if (projectTitleInput.value !== project.projectName) {
                    projectTitleInput.value = project.projectName;
                }
            }

            function renderContentBlocks(contentBlocks) {
                Object.keys(contentBlocks).forEach(key => {
                    const blockState = contentBlocks[key];
                    const textarea = document.getElementById(`${key}-textarea`);
                    const draftControls = document.querySelector(`.draft-controls[data-content-block="${key}"]`);

                    if (!textarea || !draftControls) return;

                    const activeDraft = blockState.drafts.find(d => d.id === blockState.activeDraftId);
                    if (activeDraft) {
                        if (textarea.value !== activeDraft.content) {
                            textarea.value = activeDraft.content;
                        }
                    } else {
                        // If active draft is somehow invalid, reset to first draft
                        blockState.activeDraftId = blockState.drafts[0]?.id;
                        textarea.value = blockState.drafts[0]?.content || '';
                    }

                    const select = draftControls.querySelector('.draft-controls__select');
                    const deleteBtn = draftControls.querySelector('.draft-controls__button--delete');

                    if (select) {
                        select.innerHTML = '';
                        blockState.drafts.forEach((d, index) => {
                            const option = document.createElement('option');
                            option.value = d.id;
                            const date = new Date(d.timestamp);
                            option.textContent = `Draft ${index + 1} - ${date.toLocaleTimeString()}`;
                            option.selected = d.id === blockState.activeDraftId;
                            select.appendChild(option);
                        });
                    }

                    if (deleteBtn) {
                        deleteBtn.disabled = blockState.drafts.length <= 1;
                    }
                });
            }

            function renderBuilderPallet(builderState) {
                console.log('=== RENDER BUILDER PALLET DEBUG ===');
                console.log('Builder state:', builderState);
                console.log('builderComponentData:', builderComponentData);
                
                const palletContainer = document.getElementById('prompt-builder-pallet');
                if (!palletContainer) return;
                palletContainer.innerHTML = '';

                Object.keys(builderState).forEach(key => {
                    const componentState = builderState[key];
                    console.log(`Component ${key}:`, componentState);
                    if (!componentState.active) {
                        console.log(`Skipping ${key} - not active`);
                        return;
                    }

                    const componentData = builderComponentData[key];
                    console.log(`Component data for ${key}:`, componentData);
                    if (!componentData) {
                        console.log(`Skipping ${key} - no component data`);
                        return;
                    }

                    console.log(`Rendering component ${key} with title:`, componentData.title);
                    const componentDiv = document.createElement('div');
                    componentDiv.className = 'prompt-builder__component';
                    componentDiv.dataset.componentKey = key;

                    const header = document.createElement('div');
                    header.className = 'component__header';
                    const title = document.createElement('h4');
                    title.textContent = componentData.title;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'component__remove-button';
                    removeBtn.innerHTML = '&times;';
                    header.appendChild(title);
                    header.appendChild(removeBtn);

                    const controls = document.createElement('div');
                    controls.className = 'component__controls';

                    if (key === 'context' || key === 'constraints') {
                        const textarea = document.createElement('textarea');
                        textarea.autocomplete = 'off';
                        textarea.rows = 5;
                        textarea.value = componentState.value;
                        textarea.placeholder = key === 'context'
                            ? 'Paste background info, data, or examples here...'
                            : `Define the ${componentData.title}...`;
                        controls.appendChild(textarea);
                    }
                    else if (componentData.prompts) { // role, task, format, tone etc.
                        const select = document.createElement('select');
                        
                        // Get active states for this component type
                        const activeStates = appState.activeProject.promptActiveStates[key] || {};
                        
                        // Only show prompts that are active
                        Object.keys(componentData.prompts).forEach(promptKey => {
                            // Check if this prompt is active (default to true if not in activeStates)
                            const isActive = activeStates[promptKey] !== false; // Default to true if not explicitly set
                            
                            if (isActive) {
                                const option = document.createElement('option');
                                option.value = promptKey;
                                // For keys that are already well-formatted, don't transform them.
                                // A simple check: if it contains a space or is short, use it as is.
                                option.textContent = (promptKey.includes(' ') || promptKey.length < 5) ? promptKey : promptKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                                option.selected = componentState.selection === promptKey;
                                select.appendChild(option);
                            }
                        });
                        
                        const customOption = document.createElement('option');
                        customOption.value = 'custom';
                        customOption.textContent = 'Write My Own...';
                        customOption.selected = componentState.selection === 'custom';
                        select.appendChild(customOption);
                        controls.appendChild(select);

                        const textarea = document.createElement('textarea');
                        textarea.autocomplete = 'off';
                        textarea.rows = 5;
                        textarea.value = componentState.promptValue;
                        textarea.placeholder = `Define the ${componentData.title}...`;
                        controls.appendChild(textarea);
                    }

                    componentDiv.appendChild(header);
                    componentDiv.appendChild(controls);
                    palletContainer.appendChild(componentDiv);
                });
                console.log('=== END RENDER DEBUG ===');
            }

            function renderTextTransformer(transformerState) {
                // 1. Render the active action button
                const actionButtons = document.querySelectorAll('.text-transformer__action-selector');
                actionButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.action === transformerState.activeAction);
                });

                // 2. Render the sub-options dynamically
                const optionsContainer = document.getElementById('text-transformer-options-container');
                optionsContainer.innerHTML = ''; // Clear previous options

                const activeActionConfig = transformerState.actions[transformerState.activeAction];
                if (activeActionConfig && activeActionConfig.options) {
                    Object.keys(activeActionConfig.options).forEach(optionKey => {
                        const optionText = activeActionConfig.options[optionKey];

                        const label = document.createElement('label');
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = `${transformerState.activeAction}-options`;
                        radio.value = optionKey;
                        radio.checked = activeActionConfig.activeOption === optionKey;

                        label.appendChild(radio);
                        label.appendChild(document.createTextNode(optionText));
                        optionsContainer.appendChild(label);
                    });
                }
            }

            function applyPromptSet(promptSetKey) {
                appState.activeProject.activePromptSet = promptSetKey;

                const builderState = appState.activeProject.builder;
                let template;

                // Check if the prompt set exists, if not create it
                if (!appState.activeProject.promptSets[promptSetKey]) {
                    appState.activeProject.promptSets[promptSetKey] = {};
                }
                template = JSON.parse(JSON.stringify(appState.activeProject.promptSets[promptSetKey]));

                if (template) {
                    Object.keys(builderState).forEach(key => {
                        if (template[key]) {
                            Object.assign(builderState[key], template[key]);
                        } else {
                            builderState[key].active = false;
                        }
                    });
                }
            }

            // --- EVENT HANDLER FUNCTIONS ---
            
            // UI Handlers
            function handlePanelToggle(target) {
                const panel = target.closest('.collapsible-panel');
                if (panel) {
                    panel.classList.toggle('collapsible-panel--collapsed');
                }
            }

            function handlePromptSetChange(target) {
                const promptSetKey = target.dataset.promptSetKey;
                if (promptSetKey && promptSetKey !== appState.activeProject.activePromptSet) {
                    applyPromptSet(promptSetKey);
                    render(); // Explicitly call render after applying a prompt set
                }
            }

            // Project Handlers
            function handleProjectSave() {
                appState.activeProject.lastModified = new Date().toISOString();
                const existingProjectIndex = appState.savedProjects.findIndex(p => p.currentProjectId === appState.activeProject.currentProjectId);
                if (existingProjectIndex > -1) {
                    // Update existing project in place
                    appState.savedProjects[existingProjectIndex] = JSON.parse(JSON.stringify(appState.activeProject));
                } else {
                    // Add to end if not present
                    appState.savedProjects.push(JSON.parse(JSON.stringify(appState.activeProject)));
                }
                render();
            }

            function handleProjectSaveAs() {
                // Create new project with current content
                const newProject = JSON.parse(JSON.stringify(appState.activeProject));
                newProject.currentProjectId = `proj-${Date.now()}`;
                // Remove any trailing (Copy) to avoid stacking
                newProject.projectName = appState.activeProject.projectName.replace(/( \(Copy\))+$/, '') + ' (Copy)';
                newProject.lastModified = new Date().toISOString();
                appState.savedProjects.push(newProject);
                appState.activeProject = newProject;
                render(); // Explicitly call render to update the UI
            }

            function handleProjectLoad(target) {
                const projectId = target.closest('li').dataset.projectId;
                const loadedProject = appState.savedProjects.find(p => p.currentProjectId === projectId);
                if (loadedProject) {
                    appState.activeProject = JSON.parse(JSON.stringify(loadedProject));
                    applyPromptSet(appState.activeProject.activePromptSet);
                    render();
                }
            }

            function handleProjectDelete(target) {
                const projectId = target.dataset.projectId;
                appState.savedProjects = appState.savedProjects.filter(p => p.currentProjectId !== projectId);
            }

            function handleAdminReset() {
                appState = { savedProjects: [], activeProject: getDefaultAppState() };
                applyPromptSet(appState.activeProject.activePromptSet);
            }

            // Draft Handlers
            function handleDraftSave(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                const textarea = document.getElementById(`${blockKey}-textarea`);
                if (blockKey && textarea) {
                    const contentBlock = appState.activeProject.contentBlocks[blockKey];
                    const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: textarea.value };
                    contentBlock.drafts.push(newDraft);
                    contentBlock.activeDraftId = newDraft.id;
                }
            }

            function handleDraftDelete(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                const contentBlock = appState.activeProject.contentBlocks[blockKey];
                if (contentBlock && contentBlock.drafts.length > 1) {
                    contentBlock.drafts = contentBlock.drafts.filter(d => d.id !== contentBlock.activeDraftId);
                    contentBlock.activeDraftId = contentBlock.drafts[contentBlock.drafts.length - 1].id;
                }
            }

            // Text Transformer Handlers
            function handleTextTransformerAction(target) {
                appState.activeProject.textTransformer.activeAction = target.dataset.action;
            }

            function handleTextTransformExecute() {
                const { textTransformer, contentBlocks } = appState.activeProject;
                const action = textTransformer.activeAction;
                const actionConfig = textTransformer.actions[action];

                const inputBlock = contentBlocks.textTransformerInput;
                const outputBlock = contentBlocks.textTransformerOutput;
                const currentInput = inputBlock.drafts.find(d => d.id === inputBlock.activeDraftId)?.content || '';

                let transformedContent;
                if (actionConfig.activeOption) {
                    transformedContent = `[Mock '${action}' ('${actionConfig.activeOption}') result for]:\n\n${currentInput}`;
                } else {
                    transformedContent = `[Mock '${action}' result for]:\n\n${currentInput}`;
                }

                const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: transformedContent };
                outputBlock.drafts.push(newDraft);
                outputBlock.activeDraftId = newDraft.id;
            }

            function handleTextCopyUp() {
                const inputBlock = appState.activeProject.contentBlocks.textTransformerInput;
                const outputBlock = appState.activeProject.contentBlocks.textTransformerOutput;
                const currentOutput = outputBlock.drafts.find(d => d.id === outputBlock.activeDraftId)?.content || '';

                const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: currentOutput };
                inputBlock.drafts.push(newDraft);
                inputBlock.activeDraftId = newDraft.id;
            }

            // Final Prompt Handlers
            function handleCopyToClipboard(target) {
                const finalPromptTextarea = document.getElementById('finalPrompt-textarea');
                if (finalPromptTextarea && finalPromptTextarea.value) {
                    navigator.clipboard.writeText(finalPromptTextarea.value).then(() => {
                        target.textContent = 'Copied!';
                        target.classList.add('copied');
                        setTimeout(() => {
                            target.textContent = 'Copy';
                            target.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        target.textContent = 'Error!';
                        setTimeout(() => {
                            target.textContent = 'Copy';
                        }, 2000);
                    });
                }
            }

            function handleClearContent() {
                const finalPromptState = appState.activeProject.contentBlocks.finalPrompt;
                const activeDraft = finalPromptState.drafts.find(d => d.id === finalPromptState.activeDraftId);
                if (activeDraft) {
                    activeDraft.content = '';
                }
            }

            // Content Assembly Handlers
            function handleInsertOutline() {
                const userOutlineState = appState.activeProject.contentBlocks.userOutline;
                const finalPromptState = appState.activeProject.contentBlocks.finalPrompt;

                const userOutlineDraft = userOutlineState.drafts.find(d => d.id === userOutlineState.activeDraftId);
                const finalPromptDraft = finalPromptState.drafts.find(d => d.id === finalPromptState.activeDraftId);

                if (userOutlineDraft && finalPromptDraft && userOutlineDraft.content.trim()) {
                    const textToAppend = `\n\n**CONTENT FRAMEWORK:**\n\nYou have been provided with a set of primary instructions above. Now, use the following user-provided outline as the detailed structure for the content. Adhere to this outline, expanding on each point to build out the full response.\n\n**USER-PROVIDED OUTLINE:**\n${userOutlineDraft.content}`;

                    if (finalPromptDraft.content.trim()) {
                        finalPromptDraft.content += textToAppend;
                    } else {
                        finalPromptDraft.content = textToAppend.trim();
                    }
                }
            }

            function handleAssembleAll() {
                const allOutputs = Object.keys(appState.activeProject.builder)
                    .map(key => {
                        const state = appState.activeProject.builder[key];
                        if (!state.active) return null;

                        let text = '';
                        if (key === 'context' || key === 'constraints') {
                            text = state.value || '';
                        } else {
                            text = state.promptValue || '';
                        }

                        if (!text.trim()) return null;

                        if (key === 'context') {
                            return `Use the following context:\n\n---\n${text}\n---`;
                        }
                        if (key === 'constraints') {
                            return `Apply the following constraints:\n${text}`;
                        }
                        return text;
                    })
                    .filter(text => text);

                const finalPrompt = appState.activeProject.contentBlocks.finalPrompt;
                const activeDraft = finalPrompt.drafts.find(d => d.id === finalPrompt.activeDraftId);
                if (activeDraft) activeDraft.content = allOutputs.join('\n\n');
            }

            // Component Handlers
            function handleAddComponent() {
                const inactiveComponent = Object.keys(appState.activeProject.builder).find(key => !appState.activeProject.builder[key].active);
                if (inactiveComponent) appState.activeProject.builder[inactiveComponent].active = true;
            }

            function handleRemoveComponent(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if (key && appState.activeProject.builder[key]) appState.activeProject.builder[key].active = false;
            }

            function handleComponentCheckbox(target) {
                const checkbox = target;
                const path = checkbox.dataset.path;
                if (path) {
                    const pathArray = path.split('.');
                    handleCheckboxChange(pathArray, checkbox.checked);
                }
            }

            function handleComponentActiveToggle(target) {
                const checkbox = target;
                const componentType = checkbox.dataset.componentType;
                const selection = checkbox.dataset.selection;
                const componentId = checkbox.dataset.componentId;
                
                if (componentType && selection) {
                    // Update the prompt active state in appState
                    if (!appState.activeProject.promptActiveStates[componentType]) {
                        appState.activeProject.promptActiveStates[componentType] = {};
                    }
                    appState.activeProject.promptActiveStates[componentType][selection] = checkbox.checked;
                    
                    // Update the database
                    fetch(`/api/user-components/${componentId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            is_active: checkbox.checked ? 1 : 0
                        })
                    }).catch(error => {
                        console.error('Error updating component active state:', error);
                    });
                    
                    // Trigger UI update
                    render();
                }
            }

            function handleComponentRename(target) {
                const input = target;
                const originalType = input.dataset.originalType;
                const newType = input.value.trim();
                
                if (newType && newType !== originalType) {
                    handleComponentTypeRename(originalType, newType);
                }
            }

            // Change Event Handlers
            function handleDraftSelect(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                if (blockKey) appState.activeProject.contentBlocks[blockKey].activeDraftId = target.value;
            }

            function handleTextTransformerOption(target) {
                const activeAction = appState.activeProject.textTransformer.activeAction;
                if(activeAction) {
                   appState.activeProject.textTransformer.actions[activeAction].activeOption = target.value;
                }
            }

            function handleComponentSelect(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if (key) {
                   updateComponentState(key, { selection: target.value });
                }
            }

            function handleComponentGroupCheckbox(target) {
                const checkbox = target;
                const path = checkbox.dataset.path;
                if (path) {
                    const pathArray = path.split('.');
                    handleCheckboxChange(pathArray, checkbox.checked);
                }
            }

            // Input Event Handlers
            function handleProjectTitleInput(target) {
                appState.activeProject.projectName = target.value;
            }

            function handleContentBlockInput(target) {
                const blockKey = target.id.replace('-textarea', '');
                const contentBlock = appState.activeProject.contentBlocks[blockKey];
                const activeDraft = contentBlock?.drafts.find(d => d.id === contentBlock.activeDraftId);
                if(activeDraft) activeDraft.content = target.value;
            }

            function handleComponentInput(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if(key) {
                    const componentState = appState.activeProject.builder[key];
                    if ('value' in componentState) { // For context, constraints
                        componentState.value = target.value;
                    } else { // For role, task, etc.
                        componentState.promptValue = target.value;
                        // Only save to userValue if they are in custom mode
                        if (componentState.selection === 'custom') {
                            componentState.userValue = target.value;
                        }
                    }
                }
            }

            // --- EVENT LISTENERS & LOGIC ---
            function initializeApp() {
                const appContainer = document.querySelector('.app-container');

                // Main Delegated Click Listener
                appContainer.addEventListener('click', e => {
                    const target = e.target;
                    let shouldRender = true;
                    
                    if (target.closest('.collapsible-panel__icon')) {
                        handlePanelToggle(target);
                        shouldRender = false;
                    }
                    else if (target.closest('.prompt-set-selector')) {
                        handlePromptSetChange(target);
                        shouldRender = false;
                    }
                    else if (target.id === 'save-project-button') {
                        handleProjectSave();
                    }
                    else if (target.id === 'save-as-project-button') {
                        handleProjectSaveAs();
                    }
                    else if (target.closest('#library-list li') && !target.closest('.sidebar__project-delete-button')) {
                        handleProjectLoad(target);
                    }
                    else if (target.closest('.sidebar__project-delete-button')) {
                         e.stopPropagation();
                         handleProjectDelete(target);
                    }
                    else if (target.id === 'admin-reset-button') {
                        handleAdminReset();
                    }
                    else if (target.classList.contains('draft-controls__button--save')) {
                        handleDraftSave(target);
                    }
                    else if (target.classList.contains('draft-controls__button--delete')) {
                        handleDraftDelete(target);
                    }
                     else if (target.closest('.text-transformer__action-selector')) {
                        handleTextTransformerAction(target);
                    }
                    else if (target.id === 'transform-execute-button') {
                        handleTextTransformExecute();
                    }
                     else if (target.closest('[data-action="copy-up"]')) {
                        handleTextCopyUp();
                    }
                    else if (target.id === 'copy-button') {
                        handleCopyToClipboard(target);
                    }
                    else if (target.id === 'clear-button') {
                        handleClearContent();
                    }
                    else if (target.id === 'insert-button') {
                        handleInsertOutline();
                    }
                    else if (target.id === 'assemble-all-button') {
                        handleAssembleAll();
                    }
                    else if (target.id === 'add-component-button') {
                        handleAddComponent();
                    }
                    else if (target.closest('.component__remove-button')) {
                        handleRemoveComponent(target);
                    }
                    else if (target.closest('.component-group__prompt-set-checkbox')) {
                        handleComponentGroupCheckbox(target);
                    }
                    else if (target.closest('.component-active-checkbox')) {
                        handleComponentActiveToggle(target);
                    }
                    else if (target.closest('.group-title__editable-text')) {
                        handleComponentRename(target);
                    }
                    else {
                        shouldRender = false;
                    }

                    if (shouldRender) render();
                });

                // Main Delegated Change Listener
                appContainer.addEventListener('change', e => {
                    const target = e.target;
                    let shouldRender = false;

                    if (target.closest('.draft-controls__select')) {
                        handleDraftSelect(target);
                        shouldRender = true;
                    }
                    else if (target.closest('#text-transformer-options-container') && target.type === 'radio') {
                        handleTextTransformerOption(target);
                    }
                    else if (target.closest('.prompt-builder__component') && target.tagName === 'SELECT') {
                         handleComponentSelect(target);
                         shouldRender = true;
                    }
                    else if (target.closest('.component-group__prompt-set-checkbox')) {
                        handleComponentGroupCheckbox(target);
                    }
                    else if (target.closest('.group-title__editable-text')) {
                        handleComponentRename(target);
                    }

                    if(shouldRender) render();
                });

                // Main Delegated Input Listener
                appContainer.addEventListener('input', e => {
                    const target = e.target;
                    const activeProject = appState.activeProject;

                    if (target.id === 'project-title-input') {
                        handleProjectTitleInput(target);
                    }
                    else if (target.id.endsWith('-textarea') && target.closest('.refinement-area, .article-workspace-panel, .text-transformer__area')) {
                        handleContentBlockInput(target);
                    }
                    else if (target.tagName === 'TEXTAREA' && target.closest('.prompt-builder__component')) {
                        handleComponentInput(target);
                    }
                });

                // Initial Prompt Set setup
                const promptSetsContainer = document.getElementById('prompt-sets-list');
                const promptSetKeys = Object.keys(appState.activeProject.promptSets);
                promptSetsContainer.innerHTML = '';
                promptSetKeys.forEach(key => {
                    const div = document.createElement('div');
                    div.className = 'prompt-set-selector';
                    div.dataset.promptSetKey = key;
                    div.textContent = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    promptSetsContainer.appendChild(div);
                });

                // Apply the default prompt set on initial load
                applyPromptSet(appState.activeProject.activePromptSet);
                render();
            }

            function updateComponentState(key, newState) {
                const componentState = appState.activeProject.builder[key];
                const componentData = builderComponentData[key];
                if (!componentState) return;

                // Update the selection state
                Object.assign(componentState, newState);

                if (newState.selection === 'custom') {
                    // If user selects "Write My Own...", restore their saved text.
                    componentState.promptValue = componentState.userValue;
                } else {
                    // If user selects a pre-defined prompt, load it.
                    if (componentData && componentData.prompts) {
                        componentState.promptValue = componentData.prompts[newState.selection] || '';
                    }
                }
            }

            // Generic checkbox handler for all checkbox interactions
            function handleCheckboxChange(checkboxPath, value) {
                console.log('=== CHECKBOX CHANGE DEBUG ===');
                console.log('Path:', checkboxPath);
                console.log('Value:', value);
                console.log('Current active prompt set:', appState.activeProject.activePromptSet);
                console.log('Available prompt sets:', Object.keys(appState.activeProject.promptSets));
                console.log('Blog post components:', appState.activeProject.promptSets.blog_post);
                console.log('Custom build components:', appState.activeProject.promptSets.custom_build);
                
                // Navigate to the target object in appState
                let target = appState;
                for (let i = 0; i < checkboxPath.length - 1; i++) {
                    target = target[checkboxPath[i]];
                    if (!target) {
                        console.error(`Path not found: ${checkboxPath.join('.')}`);
                        return;
                    }
                }
                
                // Set the final property
                const finalKey = checkboxPath[checkboxPath.length - 1];
                target[finalKey] = value;
                console.log(`Updated ${checkboxPath.join('.')} to ${value}`);
                
                // Check if this change affects the current prompt set
                if (checkboxPath[0] === 'activeProject' && checkboxPath[1] === 'promptSets') {
                    const promptSetKey = checkboxPath[2];
                    const componentType = checkboxPath[3];
                    
                    console.log('Prompt set key:', promptSetKey);
                    console.log('Component type:', componentType);
                    console.log('Is current prompt set?', promptSetKey === appState.activeProject.activePromptSet);
                    
                    // If this is the current active prompt set, update the builder
                    if (promptSetKey === appState.activeProject.activePromptSet) {
                        console.log('Updating builder for current prompt set');
                        // For Custom Build, ensure the component exists in the builder
                        if (!appState.activeProject.builder[componentType]) {
                            console.log('Creating missing builder component');
                            appState.activeProject.builder[componentType] = { active: true, selection: 'custom', promptValue: '', userValue: '' };
                        }
                        appState.activeProject.builder[componentType].active = value;
                        console.log(`Builder ${componentType}.active set to ${value}`);
                    } else {
                        console.log('Not current prompt set, skipping builder update');
                    }
                }
                
                // Trigger UI update
                console.log('Triggering render...');
                render();
                console.log('=== END DEBUG ===');
            }

            // Function to update component type references in appState when renaming
            async function handleComponentTypeRename(oldType, newType) {
                console.log('=== RENAME DEBUG ===');
                console.log('Renaming from:', oldType, 'to:', newType);
                console.log('Before update - builderComponentData:', builderComponentData);
                
                try {
                    updateComponentTypeInAppState(oldType, newType);
                    console.log('After update - builderComponentData:', builderComponentData);
                    
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.dataset.originalType = newType;
                    }
                    
                    // ADD: Re-render to update Prompt Builder
                    console.log('Calling render() to update UI...');
                    render();
                    console.log('=== END RENAME DEBUG ===');
                    
                } catch (error) {
                    console.error('Error renaming component:', error);
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.value = oldType;
                    }
                }
            }

            function updateComponentTypeInAppState(oldName, newName) {
                console.log(`Updating component type from "${oldName}" to "${newName}" in appState`);
                
                // Update builder references
                if (appState.activeProject.builder[oldName]) {
                    appState.activeProject.builder[newName] = appState.activeProject.builder[oldName];
                    delete appState.activeProject.builder[oldName];
                }
                
                // Update promptActiveStates references
                if (appState.activeProject.promptActiveStates[oldName]) {
                    appState.activeProject.promptActiveStates[newName] = appState.activeProject.promptActiveStates[oldName];
                    delete appState.activeProject.promptActiveStates[oldName];
                }
                
                // Update promptSets references
                Object.keys(appState.activeProject.promptSets).forEach(promptSetKey => {
                    const promptSet = appState.activeProject.promptSets[promptSetKey];
                    if (promptSet[oldName]) {
                        promptSet[newName] = promptSet[oldName];
                        delete promptSet[oldName];
                    }
                });
                
                // Update builderComponentData references
                if (builderComponentData[oldName]) {
                    builderComponentData[newName] = builderComponentData[oldName];
                    builderComponentData[newName].title = newName.charAt(0).toUpperCase() + newName.slice(1);
                    delete builderComponentData[oldName];
                }
                
                console.log('appState updated successfully');
            }

            // --- COMPONENTS ADMIN FUNCTIONALITY ---
            async function initializeComponentsAdmin() {
                let showTier2 = false;
                const toggleBtn = document.getElementById('toggle-details-btn');
                const groupedView = document.getElementById('components-grouped-view');

                if (!toggleBtn || !groupedView) return; // Only initialize if elements exist

                toggleBtn.addEventListener('click', () => {
                    showTier2 = !showTier2;
                    toggleBtn.textContent = showTier2 ? 'Hide Details' : 'Show Details';
                    document.querySelectorAll('.tier2-details-row').forEach(row => {
                        row.style.display = showTier2 ? '' : 'none';
                    });
                });

                try {
                    // Use appState components instead of fetching from database
                    const components = appState.activeProject.components;

                    // Group components by component_type
                    const grouped = {};
                    components.forEach(component => {
                        const type = component.component_type;
                        if (!grouped[type]) grouped[type] = [];
                        grouped[type].push(component);
                    });

                    // Sort group keys alphabetically
                    const groupKeys = Object.keys(grouped).sort();

                    groupedView.innerHTML = '';

                    groupKeys.forEach(type => {
                        const groupSection = document.createElement('div');
                        groupSection.className = 'component-group';
                        
                        // Group title with checkbox
                        const groupTitle = document.createElement('div');
                        groupTitle.className = 'group-title';
                        groupTitle.innerHTML = `
                            <div class="group-title__row">
                                <div class="group-title__label">
                                    <input type="text" class="group-title__editable-text" value="${type}" data-original-type="${type}">
                                </div>
                            </div>
                        `;
                        groupSection.appendChild(groupTitle);

                        // Create flex container for side-by-side layout
                        const flexContainer = document.createElement('div');
                        flexContainer.className = 'component-group__layout';

                        // Left side - Table
                        const tableContainer = document.createElement('div');
                        tableContainer.className = 'component-group__table-container';

                        // Table for subcomponents
                        const table = document.createElement('table');
                        table.id = `component-table--${type}`;
                        const thead = document.createElement('thead');
                        thead.innerHTML = `
                            <tr>
                                <th class="table__header--active">Active</th>
                                <th class="table__header--selection">Selection</th>
                                <th class="table__header--prompt">Prompt Value</th>
                            </tr>
                        `;
                        table.appendChild(thead);

                        const tbody = document.createElement('tbody');
                        // Sort by created_at descending
                        grouped[type].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                        grouped[type].forEach(component => {
                            // Main row (Tier 1)
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td class="table__cell--active"><input type="checkbox" ${component.is_active ? 'checked' : ''} class="component-active-checkbox" data-component-id="${component.id}" data-component-type="${component.component_type}" data-selection="${component.selection}"></td>
                                <td class="table__cell--selection"><input type="text" value="${component.selection || ''}" class="input--selection"></td>
                                <td class="table__cell--prompt"><textarea class="textarea--prompt">${component.prompt_value || ''}</textarea></td>
                            `;
                            tbody.appendChild(row);

                            // Details row for Tier 2
                            const detailsRow = document.createElement('tr');
                            detailsRow.className = 'tier2-details-row';
                            detailsRow.style.display = 'none';
                            const detailsCell = document.createElement('td');
                            detailsCell.colSpan = 3;
                            detailsCell.innerHTML = `
                                <div class="tier2-details-box">
                                    <strong>ID:</strong> ${component.id} &nbsp;|
                                    <strong>User Value:</strong> ${component.user_value || ''} &nbsp;|
                                    <strong>Created At:</strong> ${new Date(component.created_at).toLocaleString()} &nbsp;|
                                    <strong>Modified At:</strong> ${new Date(component.modified_at).toLocaleString()} &nbsp;|
                                    <strong>Is Starter:</strong> ${component.is_starter ? 'Yes' : 'No'}
                                </div>
                            `;
                            detailsRow.appendChild(detailsCell);
                            tbody.appendChild(detailsRow);
                        });

                        table.appendChild(tbody);
                        tableContainer.appendChild(table);

                        // Right side - Content Box
                        const contentBox = document.createElement('div');
                        contentBox.className = 'component-group__content-box';
                        
                        // Get prompt sets from appState
                        const promptSetKeys = ['custom_build', 'blog_post'];
                        const promptSetNames = {
                            'custom_build': 'Custom Build',
                            'blog_post': 'Blog Post'
                        };
                        
                        let contentHTML = `<h4>Prompt Set Status</h4>`;
                        contentHTML += `<p>Select which prompt set should include ${type} components:</p>`;
                        
                        promptSetKeys.forEach(promptSetKey => {
                            const promptSetName = promptSetNames[promptSetKey];
                            let isActive = false;
                            
                            // Check if this component type is active in this prompt set
                            if (promptSetKey === 'custom_build') {
                                // Check if custom_build exists in promptSets, if not create it with default active state
                                if (!appState.activeProject.promptSets[promptSetKey]) {
                                    appState.activeProject.promptSets[promptSetKey] = {};
                                }
                                if (!appState.activeProject.promptSets[promptSetKey][type]) {
                                    appState.activeProject.promptSets[promptSetKey][type] = { active: true };
                                }
                                isActive = appState.activeProject.promptSets[promptSetKey][type].active;
                            } else if (appState.activeProject.promptSets[promptSetKey] && appState.activeProject.promptSets[promptSetKey][type]) {
                                // Check the specific prompt set configuration
                                isActive = appState.activeProject.promptSets[promptSetKey][type].active;
                            }
                            
                            const statusText = isActive ? 'Active' : 'Inactive';
                            const itemClass = isActive ? 'component-group__prompt-set-item component-group__prompt-set-item--active' : 'component-group__prompt-set-item component-group__prompt-set-item--inactive';
                            const statusClass = isActive ? 'component-group__status-text component-group__status-text--active' : 'component-group__status-text component-group__status-text--inactive';
                            
                            contentHTML += `
                                <div class="${itemClass}" data-component-type="${type}" data-prompt-set="${promptSetKey}">
                                    <input type="checkbox" ${isActive ? 'checked' : ''} class="component-group__prompt-set-checkbox" data-path="activeProject.promptSets.${promptSetKey}.${type}.active">
                                    <span class="component-group__prompt-set-name">${promptSetName}</span>
                                    <span class="${statusClass}">${statusText}</span>
                                </div>
                            `;
                        });
                        
                        contentBox.innerHTML = contentHTML;

                        // Add both to flex container
                        flexContainer.appendChild(tableContainer);
                        flexContainer.appendChild(contentBox);
                        
                        groupSection.appendChild(flexContainer);
                        groupedView.appendChild(groupSection);
                    });
                } catch (error) {
                    console.error('Error fetching components:', error);
                    const errorMessage = document.getElementById('error-message');
                    if (errorMessage) {
                        errorMessage.textContent = 'An error occurred while fetching components. Please try again later.';
                        errorMessage.style.display = 'block';
                    }
                }
            }

            // --- INITIALIZATION ---
            setupUIEventListeners();
            
            // Initialize components admin functionality
            initializeComponentsAdmin();
            
            // Function to populate prompt active states from database
            async function populatePromptActiveStates() {
                try {
                    // Use appState components instead of fetching from database
                    const components = appState.activeProject.components;
                    
                    // Group components by component_type and populate active states
                    components.forEach(component => {
                        const type = component.component_type;
                        const selection = component.selection;
                        
                        if (!appState.activeProject.promptActiveStates[type]) {
                            appState.activeProject.promptActiveStates[type] = {};
                        }
                        
                        // Set the active state based on the database is_active field
                        appState.activeProject.promptActiveStates[type][selection] = component.is_active === 1;
                    });
                    
                    console.log('Prompt active states populated:', appState.activeProject.promptActiveStates);
                } catch (error) {
                    console.error('Error populating prompt active states:', error);
                }
            }
            
            // Function to load components into appState
            async function loadComponentsIntoAppState() {
                try {
                    const response = await fetch('/api/user-components');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const components = await response.json();
                    appState.activeProject.components = components;
                    console.log('Components loaded into appState:', components.length, 'components');
                    
                    // Build builderComponentData from actual components
                    builderComponentData = {};
                    components.forEach(component => {
                        const type = component.component_type;
                        if (!builderComponentData[type]) {
                            builderComponentData[type] = {
                                title: type,
                                prompts: {}
                            };
                        }
                        // Only add to prompts if selection and prompt_value exist
                        if (component.selection && component.prompt_value) {
                            builderComponentData[type].prompts[component.selection] = component.prompt_value;
                        }
                    });
                    console.log('builderComponentData built from components:', builderComponentData);
                } catch (error) {
                    console.error('Error loading components into appState:', error);
                }
            }
            
            // Fetch components from backend before initializing app
            loadComponentsIntoAppState()
                .then(() => {
                    return populatePromptActiveStates();
                })
                .then(() => {
                    // Initialize components admin functionality AFTER components are loaded
                    initializeComponentsAdmin();
                    initializeApp();
                })
                .catch(err => {
                    alert('Error loading components: ' + err.message);
                });
        });
    </script>
</body>
</html>