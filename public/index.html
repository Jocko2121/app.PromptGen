<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Prompt Generator - V2</title>
    <link rel="stylesheet" href="/styles/main.css">
</head>
<body class="light-mode">

    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar__header">
                <h2>Prompt Gen</h2>
            </div>
            <div class="sidebar__content">
                <h4 class="sidebar__sub-heading">Projects</h4>
                <ul id="library-list" class="sidebar__list">
                </ul>

                <h4 class="sidebar__sub-heading">Prompt Sets</h4>
                <div id="prompt-sets-list" class="sidebar__list">
                </div>
            </div>
            <div class="sidebar__footer">
                <button id="admin-reset-button" data-action="adminReset">Admin: Hard Reset</button>
            </div>
        </aside>

        <div class="app-bar">
            <div class="app-bar__section app-bar__project">
                <span class="sidebar__hamburger" id="hamburger-button">&#9776;</span>
                <label for="project-name-input" class="project-hub__label">Project Name:</label>
                <input type="text" id="project-name-input" class="panel__title-input project-hub__input" data-action="projectTitleInput" placeholder="Enter project name...">
                <div class="panel__header-buttons">
                    <button id="save-project-button" class="button--primary" data-action="saveProject" title="Save Project" aria-label="Save Project">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 21a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2H5zm7-14a4 4 0 1 0 0 8 4 4 0 0 0 0-8zM6 5v4h10V5H6z"/></svg>
                    </button>
                    <button id="save-as-project-button" class="button--primary" data-action="saveAsProject" title="Save as New Project" aria-label="Save as New Project">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6zm-1 9h-3v3H8v-3H5v-2h3V6h2v3h3v2z"/></svg>
                    </button>
                </div>
            </div>
            <div class="app-bar__section app-bar__tools">Tools Section</div>
            <div class="app-bar__section app-bar__settings">Settings Section</div>
        </div>

        <div class="main-content-wrapper">
            <div class="tab-bar" id="main-tab-bar">
                <div class="tab-bar__tabs">
                    <button class="tab-button active" data-tab-target="#prompt-builder-panel">Prompt Builder</button>
                    <button class="tab-button" data-tab-target="#database-components-panel">Database Components</button>
                    <button class="tab-button" data-tab-target="#refinement-panel">Refinement</button>
                    <button class="tab-button" data-tab-target="#text-transformer-panel">Text Transformer</button>
                    <button class="tab-button" data-tab-target="#article-workspace-panel">Article Workspace</button>
                    <!-- <button class="tab-button" data-tab-target="#settings-panel">Settings</button> -->
                </div>
                <div class="tab-bar__icons">
                    <button class="tab-button tab-button--icon" data-tab-target="#settings-panel" title="Settings">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1 0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <main class="main-content">
                <section class="panel collapsible-panel tab-content active" id="prompt-builder-panel">
                    <div class="panel__header">
                        <h3>Prompt Builder</h3>
                        <div class="panel__header-buttons">
                             <button id="add-component-button" class="button--utility" data-action="addComponent">Add Component</button>
                        </div>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="prompt-builder__pallet" id="prompt-builder-pallet">
                                </div>
                            <div class="prompt-assembler__output">
                                <div class="generate-button-container">
                                    <button id="assemble-all-button" class="button--primary" data-action="assembleAll">Add All to Final Prompt</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="database-components-panel">
                    <div class="panel__header">
                        <h3>Database Components</h3>
                        <div style="display: flex; gap: 10px; align-items: center; margin-right: 20px;">
                            <button id="toggle-details-btn" class="button--utility" data-action="toggleAdminDetails">Show Details</button>
                            <button id="save-all-btn" disabled class="button--utility">Save All</button>
                        </div>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper components-admin">
                            <div id="error-message" class="error error__message"></div>
                            <div id="components-grouped-view"></div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="refinement-panel">
                     <div class="panel__header">
                        <h3>Refinement</h3>
                         <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                     <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div class="refinement-area">
                                <div class="panel user-outline-panel">
                                    <div class="panel__header"><h3>User Outline</h3></div>
                                    <textarea id="userOutline-textarea" autocomplete="off" placeholder="Write your outline or dump your thoughts here..." data-action="contentBlockInput"></textarea>
                                    <div class="draft-controls" data-content-block="userOutline"><select class="draft-controls__select" data-action="draftSelect"></select><button class="draft-controls__button--save" data-action="draftSave">Save</button><button class="draft-controls__button--delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                </div>
                                <div class="insert-button-container">
                                    <button id="insert-button" class="button--primary" title="Insert Outline into Final Prompt" data-action="insertOutline">&rarr;</button>
                                </div>
                                <div class="panel final-prompt-panel">
                                    <div class="panel__header">
                                        <h3>Final Prompt</h3>
                                        <div class="panel__header-buttons">
                                            <button id="copy-button" class="button--utility" data-action="copyToClipboard">Copy</button>
                                            <button id="clear-button" class="button--utility" data-action="clearContent">Clear</button>
                                        </div>
                                    </div>
                                    <textarea id="finalPrompt-textarea" autocomplete="off" placeholder="The final, combined prompt will appear here..." data-action="contentBlockInput"></textarea>
                                    <div class="draft-controls" data-content-block="finalPrompt"><select class="draft-controls__select" data-action="draftSelect"></select><button class="draft-controls__button--save" data-action="draftSave">Save</button><button class="draft-controls__button--delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                </div>
                            </div>
                        </div>
                     </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="text-transformer-panel">
                    <div class="panel__header">
                        <h3>Text Transformer</h3>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <div id="action-engine-panel-content">
                                <div class="text-transformer__area">
                                    <div class="panel">
                                        <div class="panel__header"><h3>Input</h3></div>
                                        <textarea id="textTransformerInput-textarea" autocomplete="off" placeholder="Paste text here to transform it..." data-action="contentBlockInput"></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerInput"><select class="draft-controls__select" data-action="draftSelect"></select><button class="draft-controls__button--save" data-action="draftSave">Save</button><button class="draft-controls__button--delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                    </div>
                                    <div class="text-transformer__actions-container">
                                        <button class="text-transformer__action-selector" data-action="selectTextTransformerAction" data-transformer-action="summarize">Summarize</button>
                                        <button class="text-transformer__action-selector" data-action="selectTextTransformerAction" data-transformer-action="rewrite">Rewrite</button>
                                        <button class="text-transformer__action-selector" data-action="selectTextTransformerAction" data-transformer-action="analyze">Analyze</button>

                                        <div id="text-transformer-options-container"></div>

                                        <button id="transform-execute-button" class="button--primary" data-action="executeTextTransform">Transform</button>
                                        <hr class="text-transformer__divider">
                                        <button class="button--utility text-transformer__action-button" data-action="copyUp" title="Copy Output to Input">‚Üë</button>
                                    </div>
                                    <div class="panel">
                                        <div class="panel__header"><h3>Output</h3></div>
                                        <textarea id="textTransformerOutput-textarea" autocomplete="off" placeholder="Transformed text will appear here..." data-action="contentBlockInput"></textarea>
                                        <div class="draft-controls" data-content-block="textTransformerOutput"><select class="draft-controls__select" data-action="draftSelect"></select><button class="draft-controls__button--save" data-action="draftSave">Save</button><button class="draft-controls__button--delete" data-action="draftDelete">üóëÔ∏è</button></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel collapsible-panel tab-content" id="article-workspace-panel">
                    <div class="panel__header">
                        <h3>Article Workspace</h3>
                        <span class="collapsible-panel__icon">&#9660;</span>
                    </div>
                    <div class="collapsible-panel__content">
                        <div class="collapsible-panel__inner-wrapper">
                            <textarea id="articleWorkspace-textarea" autocomplete="off" placeholder="Paste the final draft created by the LLM here..." data-action="contentBlockInput"></textarea>
                            <div class="draft-controls" data-content-block="articleWorkspace"><select class="draft-controls__select" data-action="draftSelect"></select><button class="draft-controls__button--save" data-action="draftSave">Save</button><button class="draft-controls__button--delete" data-action="draftDelete">üóëÔ∏è</button></div>
                        </div>
                    </div>
                </section>
                
                <section class="panel tab-content" id="settings-panel">
                    <div class="panel__header">
                        <h3>Settings</h3>
                    </div>
                    <div class="settings-panel__content">
                        <div class="settings-group">
                            <h4>Theme</h4>
                            <div class="settings-group__control">
                                                            <button id="theme-light-button" class="button--utility button--theme hidden">‚òÄÔ∏è</button>
                            <button id="theme-dark-button" class="button--utility button--theme">üåô</button>
                            </div>
                        </div>
                    </div>
                </section>

            </main>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /*
            * == AI PROMPT GENERATOR V2 - ARCHITECTURE BRIEFING ==
            *
            * GUIDING PRINCIPLES:
            * - The application is a state-driven, single-page app. All UI is rendered from the 'appState' object.
            * - The core data model is a "Project," which contains all settings and content drafts. A "Project" is represented by the 'activeProject' object within the main 'appState'.
            * - All data saving/loading (Drafts and Projects) is IN-MEMORY for this wireframe. No persistent storage is used. Reloading the page will reset everything.
            */

            // --- UI-ONLY EVENT LISTENERS ---
            function setupUIEventListeners() {
                const hamburgerButton = document.getElementById('hamburger-button');
                const sidebar = document.getElementById('sidebar');
                const lightThemeButton = document.getElementById('theme-light-button');
                const darkThemeButton = document.getElementById('theme-dark-button');
                const body = document.body;
                const dbToggleButton = document.getElementById('toggle-database-section');
                const dbPanel = document.getElementById('database-components-panel');

                if (hamburgerButton && sidebar) {
                    hamburgerButton.addEventListener('click', () => {
                        sidebar.classList.toggle('sidebar--collapsed');
                    });
                }

                if(lightThemeButton && darkThemeButton && body) {
                    lightThemeButton.addEventListener('click', () => {
                        body.classList.add('light-mode');
                        lightThemeButton.classList.add('hidden');
                        darkThemeButton.classList.remove('hidden');
                    });
                    darkThemeButton.addEventListener('click', () => {
                        body.classList.remove('light-mode');
                        darkThemeButton.classList.add('hidden');
                        lightThemeButton.classList.remove('hidden');
                    });
                }

                if (dbToggleButton && dbPanel) {
                    dbToggleButton.addEventListener('click', () => {
                        const isVisible = dbPanel.style.display !== 'none';
                        dbPanel.style.display = isVisible ? 'none' : '';
                        dbToggleButton.classList.toggle('button--primary', !isVisible);
                        dbToggleButton.classList.toggle('button--utility', isVisible);
                    });
                }
            }


            // --- DATA MODELS (CONSTANTS) ---
            // builderComponentData has been moved to the backend and is now seeded from starter-components.js into the database.
            let builderComponentData = {};

            // --- APPLICATION STATE (THE SINGLE SOURCE OF TRUTH) ---
            function getDefaultAppState() {
                const now = Date.now();
                return {
                    currentProjectId: `proj-${now}`,
                    projectName: 'Untitled Project',
                    activePromptSet: 'custom_build',
                    promptSets: {
                        custom_build: {}, // Ensures the default active set exists
                        blog_post: {
                            role: { active: true, selection: 'custom', promptValue: 'Act as an expert blogger and SEO specialist.', userValue: 'Act as an expert blogger and SEO specialist.' },
                            task: { active: true, selection: 'write', promptValue: 'a comprehensive and engaging blog post about [topic].', userValue: '' },
                            context: { active: false, value: '' },
                            format: { active: true, selection: 'paragraphs', promptValue: 'Placeholder: Format the output as standard paragraphs.', userValue: '' },
                            tone: { active: true, selection: 'casual', promptValue: 'Placeholder: Use a casual and friendly tone.', userValue: '' },
                            constraints: { active: true, value: 'The blog post should be at least 800 words and include a clear call to action.' }
                        }
                    },
                    builder: {
                        role: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        task: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        job: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        audiencePro: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        audienceSilly: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        format: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        tone: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        length: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        pov: { active: true, selection: 'custom', promptValue: '', userValue: '' },
                        context: { active: true, value: '' },
                        constraints: { active: true, value: ''},
                    },
                    // New: Prompt-level active states for each component type
                    promptActiveStates: {
                        role: {},
                        task: {},
                        job: {},
                        audiencePro: {},
                        audienceSilly: {},
                        format: {},
                        tone: {},
                        length: {},
                        pov: {},
                        context: {},
                        constraints: {}
                    },
                    visibility: [], // NEW: To store visibility from the DB
                    // New: Store all components in appState
                    components: [],
                    contentBlocks: {
                        userOutline: { activeDraftId: `draft-${now+1}`, drafts: [{ id: `draft-${now+1}`, timestamp: new Date().toISOString(), content: '' }] },
                        finalPrompt: { activeDraftId: `draft-${now+2}`, drafts: [{ id: `draft-${now+2}`, timestamp: new Date().toISOString(), content: '' }] },
                        articleWorkspace: { activeDraftId: `draft-${now+3}`, drafts: [{ id: `draft-${now+3}`, timestamp: new Date().toISOString(), content: '' }] },
                        textTransformerInput: { activeDraftId: `draft-${now+4}`, drafts: [{ id: `draft-${now+4}`, timestamp: new Date().toISOString(), content: '' }] },
                        textTransformerOutput: { activeDraftId: `draft-${now+5}`, drafts: [{ id: `draft-${now+5}`, timestamp: new Date().toISOString(), content: '' }] }
                    },
                    textTransformer: {
                        activeAction: 'analyze',
                        actions: {
                            summarize: {},
                            rewrite: {
                                activeOption: 'casual',
                                options: {
                                    professional: 'Rewrite in a professional tone.',
                                    casual: 'Rewrite in a casual tone.',
                                    empathetic: 'Rewrite with more empathy.'
                                }
                            },
                            analyze: {
                                activeOption: 'proofread',
                                options: {
                                    proofread: 'Proofread for grammar & spelling.',
                                    identify_themes: 'Identify the main themes.',
                                    fact_check: 'Fact-check for accuracy.'
                                }
                            }
                        }
                    }
                };
            }

            let appState = {
                savedProjects: [],
                activeProject: getDefaultAppState()
            };

            // --- RENDER FUNCTIONS ---
            function render() {
                const project = appState.activeProject;
                renderPromptSets(project.activePromptSet);
                renderProjectHub(project);
                renderBuilderPallet(project.builder);
                renderContentBlocks(project.contentBlocks);
                renderLibrary();
                renderTextTransformer(project.textTransformer);
                renderComponentsAdmin();
            }

            function renderPromptSetSelectors() {
                const promptSetsContainer = document.getElementById('prompt-sets-list');
                const promptSets = appState.activeProject.promptSets || [];
                promptSetsContainer.innerHTML = '';
                promptSets.forEach(set => {
                    const div = document.createElement('div');
                    div.className = 'prompt-set-selector';
                    div.dataset.promptSetKey = set.set_key;
                    div.textContent = set.display_name;
                    promptSetsContainer.appendChild(div);
                });
            }

            function renderPromptSets(activePromptSetKey) {
                const promptSetSelectors = document.querySelectorAll('.prompt-set-selector');
                promptSetSelectors.forEach(selector => {
                    selector.classList.toggle('active', selector.dataset.promptSetKey === activePromptSetKey);
                });

                let template;

                // NEW: Logic updated for the new data structure
                const selectedPromptSet = appState.activeProject.promptSets.find(ps => ps.set_key === activePromptSetKey);
                if (!selectedPromptSet) {
                    console.error(`Prompt set with key "${activePromptSetKey}" not found.`);
                    return;
                }

                const visibilityForSet = appState.activeProject.visibility.filter(v => v.prompt_set_id === selectedPromptSet.id);
                
                Object.keys(appState.activeProject.builder).forEach(key => {
                    const componentType = appState.activeProject.components.find(c => c.type_key === key);
                    if (componentType) {
                        const visibilityRecord = visibilityForSet.find(v => v.component_type_id === componentType.component_type_id);
                        // A component is active in the builder if a visibility record exists and is set to visible.
                        appState.activeProject.builder[key].active = visibilityRecord ? !!visibilityRecord.is_visible : false;
                    } else {
                        appState.activeProject.builder[key].active = false;
                    }
                });
            }

            function renderLibrary() {
                const libraryList = document.getElementById('library-list');
                if (!libraryList) return;
                libraryList.innerHTML = '';

                let foundActive = false;
                appState.savedProjects.forEach(project => {
                    const li = document.createElement('li');
                    if (project.currentProjectId === appState.activeProject.currentProjectId) {
                        li.className = 'active';
                        foundActive = true;
                    }

                    const textSpan = document.createElement('span');
                    textSpan.textContent = project.projectName;
                    textSpan.style.flexGrow = '1';
                    textSpan.setAttribute('data-action', 'loadProject');

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'sidebar__project-delete-button';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.dataset.projectId = project.currentProjectId;
                    deleteBtn.setAttribute('data-action', 'deleteProject');

                    li.appendChild(textSpan);
                    li.appendChild(deleteBtn);
                    li.dataset.projectId = project.currentProjectId;
                    libraryList.appendChild(li);
                });

                // If the active project is not in savedProjects, show it at the end with '(Unsaved)'
                if (!foundActive && appState.activeProject) {
                    const li = document.createElement('li');
                    li.className = 'active';
                    const textSpan = document.createElement('span');
                    textSpan.textContent = appState.activeProject.projectName + ' (Unsaved)';
                    textSpan.style.flexGrow = '1';
                    textSpan.setAttribute('data-action', 'loadProject');
                    li.appendChild(textSpan);
                    li.dataset.projectId = appState.activeProject.currentProjectId;
                    libraryList.appendChild(li);
                }
            }

            function renderProjectHub(project) {
                const projectTitleInput = document.getElementById('project-name-input');
                if (projectTitleInput.value !== project.projectName) {
                    projectTitleInput.value = project.projectName;
                }
            }

            function renderContentBlocks(contentBlocks) {
                Object.keys(contentBlocks).forEach(key => {
                    const blockState = contentBlocks[key];
                    const textarea = document.getElementById(`${key}-textarea`);
                    const draftControls = document.querySelector(`.draft-controls[data-content-block="${key}"]`);

                    if (!textarea || !draftControls) return;

                    const activeDraft = blockState.drafts.find(d => d.id === blockState.activeDraftId);
                    if (activeDraft) {
                        if (textarea.value !== activeDraft.content) {
                            textarea.value = activeDraft.content;
                        }
                    } else {
                        // If active draft is somehow invalid, reset to first draft
                        blockState.activeDraftId = blockState.drafts[0]?.id;
                        textarea.value = blockState.drafts[0]?.content || '';
                    }

                    const select = draftControls.querySelector('.draft-controls__select');
                    const deleteBtn = draftControls.querySelector('.draft-controls__button--delete');

                    if (select) {
                        select.innerHTML = '';
                        blockState.drafts.forEach((d, index) => {
                            const option = document.createElement('option');
                            option.value = d.id;
                            const date = new Date(d.timestamp);
                            option.textContent = `Draft ${index + 1} - ${date.toLocaleTimeString()}`;
                            option.selected = d.id === blockState.activeDraftId;
                            select.appendChild(option);
                        });
                    }

                    if (deleteBtn) {
                        deleteBtn.disabled = blockState.drafts.length <= 1;
                    }
                });
            }

            function renderBuilderPallet(builderState) {
                const palletContainer = document.getElementById('prompt-builder-pallet');
                if (!palletContainer) return;
                palletContainer.innerHTML = '';

                Object.keys(builderState).forEach(key => {
                    const componentState = builderState[key];
                    if (!componentState.active) {
                        return;
                    }

                    const componentData = builderComponentData[key];
                    if (!componentData) {
                        return;
                    }

                    const componentDiv = document.createElement('div');
                    componentDiv.className = 'prompt-builder__component';
                    componentDiv.dataset.componentKey = key;

                    const header = document.createElement('div');
                    header.className = 'component__header';
                    const title = document.createElement('h4');
                    title.textContent = componentData.title;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'component__remove-button';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.setAttribute('data-action', 'removeComponent');
                    header.appendChild(title);
                    header.appendChild(removeBtn);

                    const controls = document.createElement('div');
                    controls.className = 'component__controls';

                    if (key === 'context' || key === 'constraints') {
                        const textarea = document.createElement('textarea');
                        textarea.autocomplete = 'off';
                        textarea.rows = 5;
                        textarea.value = componentState.value;
                        textarea.placeholder = key === 'context'
                            ? 'Paste background info, data, or examples here...'
                            : `Define the ${componentData.title}...`;
                        textarea.setAttribute('data-action', 'componentInput');
                        controls.appendChild(textarea);
                    }
                    else if (componentData.prompts) { // role, task, format, tone etc.
                        const select = document.createElement('select');
                        select.setAttribute('data-action', 'componentSelect');
                        
                        // Filter the master list of components to get only the active ones for this type.
                        const activePromptsForType = appState.activeProject.components.filter(
                            c => c.type_key === key && c.is_active
                        );

                        activePromptsForType.forEach(prompt => {
                            const option = document.createElement('option');
                            option.value = prompt.selection;
                            // For keys that are already well-formatted, don't transform them.
                            // A simple check: if it contains a space or is short, use it as is.
                            option.textContent = (prompt.selection.includes(' ') || prompt.selection.length < 5) ? prompt.selection : prompt.selection.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            option.selected = componentState.selection === prompt.selection;
                            select.appendChild(option);
                        });
                        
                        const customOption = document.createElement('option');
                        customOption.value = 'custom';
                        customOption.textContent = 'Write My Own...';
                        customOption.selected = componentState.selection === 'custom';
                        select.appendChild(customOption);
                        controls.appendChild(select);

                        const textarea = document.createElement('textarea');
                        textarea.autocomplete = 'off';
                        textarea.rows = 5;
                        textarea.value = componentState.promptValue;
                        textarea.placeholder = `Define the ${componentData.title}...`;
                        textarea.setAttribute('data-action', 'componentInput');
                        controls.appendChild(textarea);
                    }

                    componentDiv.appendChild(header);
                    componentDiv.appendChild(controls);
                    palletContainer.appendChild(componentDiv);
                });
            }

            function renderTextTransformer(transformerState) {
                // 1. Render the active action button
                const actionButtons = document.querySelectorAll('.text-transformer__action-selector');
                actionButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.transformerAction === transformerState.activeAction);
                });

                // 2. Render the sub-options dynamically
                const optionsContainer = document.getElementById('text-transformer-options-container');
                optionsContainer.innerHTML = ''; // Clear previous options

                const activeActionConfig = transformerState.actions[transformerState.activeAction];
                if (activeActionConfig && activeActionConfig.options) {
                    Object.keys(activeActionConfig.options).forEach(optionKey => {
                        const optionText = activeActionConfig.options[optionKey];

                        const label = document.createElement('label');
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.name = `${transformerState.activeAction}-options`;
                        radio.value = optionKey;
                        radio.checked = activeActionConfig.activeOption === optionKey;
                        radio.setAttribute('data-action', 'selectTextTransformerOption');

                        label.appendChild(radio);
                        label.appendChild(document.createTextNode(optionText));
                        optionsContainer.appendChild(label);
                    });
                }
            }

            function applyPromptSet(promptSetKey) {
                appState.activeProject.activePromptSet = promptSetKey;

                const builderState = appState.activeProject.builder;
                let template;

                // Check if the prompt set exists, if not create it
                if (!appState.activeProject.promptSets[promptSetKey]) {
                    appState.activeProject.promptSets[promptSetKey] = {};
                }
                template = JSON.parse(JSON.stringify(appState.activeProject.promptSets[promptSetKey]));

                if (template) {
                    Object.keys(builderState).forEach(key => {
                        if (template[key]) {
                            Object.assign(builderState[key], template[key]);
                        } else {
                            builderState[key].active = false;
                        }
                    });
                }
            }

            // --- EVENT HANDLER FUNCTIONS ---
            let showAdminDetails = false; // Moved to a higher scope

            // UI Handlers
            function handlePanelToggle(target) {
                const panel = target.closest('.collapsible-panel');
                if (panel) {
                    panel.classList.toggle('collapsible-panel--collapsed');
                }
            }

            function switchToTab(targetContentId) {
                const mainContent = document.querySelector('.main-content');
                if (!mainContent) return;

                const tabContents = mainContent.querySelectorAll('.tab-content');
                const tabBar = document.getElementById('main-tab-bar');
                if (!tabBar) return;

                const tabButtons = tabBar.querySelectorAll('.tab-button');

                // Deactivate all buttons and content
                tabButtons.forEach(button => button.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));

                // Activate the target content
                const targetContent = mainContent.querySelector(targetContentId);
                if (targetContent) {
                    targetContent.classList.add('active');
                }

                // Activate the corresponding button
                const targetButton = tabBar.querySelector(`[data-tab-target="${targetContentId}"]`);
                if (targetButton) {
                    targetButton.classList.add('active');
                }
            }

            function handleTabSwitch(target) {
                const targetButton = target.closest('.tab-button');
                if (!targetButton || targetButton.classList.contains('active')) return;
                const targetContentId = targetButton.dataset.tabTarget;
                switchToTab(targetContentId);
            }

            function handleAdminToggleDetails(target) {
                showAdminDetails = !showAdminDetails;
                target.textContent = showAdminDetails ? 'Hide Details' : 'Show Details';
                // This is simpler as the rows will be shown/hidden on next render
                render();
            }

            function handlePromptSetChange(target) {
                const promptSetKey = target.dataset.promptSetKey;
                if (promptSetKey && promptSetKey !== appState.activeProject.activePromptSet) {
                    applyPromptSet(promptSetKey);
                    render();
                }
            }

            // Project Handlers - Refactored for declarative model
            function handleProjectSave() {
                appState.activeProject.lastModified = new Date().toISOString();
                const existingProjectIndex = appState.savedProjects.findIndex(p => p.currentProjectId === appState.activeProject.currentProjectId);
                if (existingProjectIndex > -1) {
                    appState.savedProjects[existingProjectIndex] = JSON.parse(JSON.stringify(appState.activeProject));
                } else {
                    appState.savedProjects.push(JSON.parse(JSON.stringify(appState.activeProject)));
                }
            }

            function handleProjectSaveAs() {
                const newProject = JSON.parse(JSON.stringify(appState.activeProject));
                newProject.currentProjectId = `proj-${Date.now()}`;
                newProject.projectName = appState.activeProject.projectName.replace(/( \(Copy\))+$/, '') + ' (Copy)';
                newProject.lastModified = new Date().toISOString();
                appState.savedProjects.push(newProject);
                appState.activeProject = newProject;
            }

            function handleProjectLoad(target) {
                const projectId = target.closest('li').dataset.projectId;
                const loadedProject = appState.savedProjects.find(p => p.currentProjectId === projectId);
                if (loadedProject) {
                    appState.activeProject = JSON.parse(JSON.stringify(loadedProject));
                    applyPromptSet(appState.activeProject.activePromptSet);
                }
            }

            function handleProjectDelete(target, e) {
                e.stopPropagation();
                const projectId = target.closest('li').dataset.projectId;
                appState.savedProjects = appState.savedProjects.filter(p => p.currentProjectId !== projectId);
            }

            function handleAdminReset() {
                appState = { savedProjects: [], activeProject: getDefaultAppState() };
                applyPromptSet(appState.activeProject.activePromptSet);
            }

            // Draft Handlers
            function handleDraftSave(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                const textarea = document.getElementById(`${blockKey}-textarea`);
                if (blockKey && textarea) {
                    const contentBlock = appState.activeProject.contentBlocks[blockKey];
                    const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: textarea.value };
                    contentBlock.drafts.push(newDraft);
                    contentBlock.activeDraftId = newDraft.id;
                }
            }

            function handleDraftDelete(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                const contentBlock = appState.activeProject.contentBlocks[blockKey];
                if (contentBlock && contentBlock.drafts.length > 1) {
                    contentBlock.drafts = contentBlock.drafts.filter(d => d.id !== contentBlock.activeDraftId);
                    contentBlock.activeDraftId = contentBlock.drafts[contentBlock.drafts.length - 1].id;
                }
            }

            // Text Transformer Handlers
            function handleTextTransformerAction(target) {
                appState.activeProject.textTransformer.activeAction = target.dataset.transformerAction;
            }

            function handleTextTransformExecute() {
                const { textTransformer, contentBlocks } = appState.activeProject;
                const action = textTransformer.activeAction;
                const actionConfig = textTransformer.actions[action];

                const inputBlock = contentBlocks.textTransformerInput;
                const outputBlock = contentBlocks.textTransformerOutput;
                const currentInput = inputBlock.drafts.find(d => d.id === inputBlock.activeDraftId)?.content || '';

                let transformedContent;
                if (actionConfig.activeOption) {
                    transformedContent = `[Mock '${action}' ('${actionConfig.activeOption}') result for]:\n\n${currentInput}`;
                } else {
                    transformedContent = `[Mock '${action}' result for]:\n\n${currentInput}`;
                }

                const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: transformedContent };
                outputBlock.drafts.push(newDraft);
                outputBlock.activeDraftId = newDraft.id;
            }

            function handleTextCopyUp() {
                const inputBlock = appState.activeProject.contentBlocks.textTransformerInput;
                const outputBlock = appState.activeProject.contentBlocks.textTransformerOutput;
                const currentOutput = outputBlock.drafts.find(d => d.id === outputBlock.activeDraftId)?.content || '';

                const newDraft = { id: `draft-${Date.now()}`, timestamp: new Date().toISOString(), content: currentOutput };
                inputBlock.drafts.push(newDraft);
                inputBlock.activeDraftId = newDraft.id;
            }

            // Final Prompt Handlers
            function handleCopyToClipboard(target) {
                const finalPromptTextarea = document.getElementById('finalPrompt-textarea');
                if (finalPromptTextarea && finalPromptTextarea.value) {
                    navigator.clipboard.writeText(finalPromptTextarea.value).then(() => {
                        target.textContent = 'Copied!';
                        target.classList.add('copied');
                        setTimeout(() => {
                            target.textContent = 'Copy';
                            target.classList.remove('copied');
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        target.textContent = 'Error!';
                        setTimeout(() => {
                            target.textContent = 'Copy';
                        }, 2000);
                    });
                }
            }

            function handleClearContent() {
                const finalPromptState = appState.activeProject.contentBlocks.finalPrompt;
                const activeDraft = finalPromptState.drafts.find(d => d.id === finalPromptState.activeDraftId);
                if (activeDraft) {
                    activeDraft.content = '';
                }
            }

            // Content Assembly Handlers
            function handleInsertOutline() {
                const userOutlineState = appState.activeProject.contentBlocks.userOutline;
                const finalPromptState = appState.activeProject.contentBlocks.finalPrompt;

                const userOutlineDraft = userOutlineState.drafts.find(d => d.id === userOutlineState.activeDraftId);
                const finalPromptDraft = finalPromptState.drafts.find(d => d.id === finalPromptState.activeDraftId);

                if (userOutlineDraft && finalPromptDraft && userOutlineDraft.content.trim()) {
                    const textToAppend = `\n\n**CONTENT FRAMEWORK:**\n\nYou have been provided with a set of primary instructions above. Now, use the following user-provided outline as the detailed structure for the content. Adhere to this outline, expanding on each point to build out the full response.\n\n**USER-PROVIDED OUTLINE:**\n${userOutlineDraft.content}`;

                    if (finalPromptDraft.content.trim()) {
                        finalPromptDraft.content += textToAppend;
                    } else {
                        finalPromptDraft.content = textToAppend.trim();
                    }
                }
            }

            function handleAssembleAll() {
                const allOutputs = Object.keys(appState.activeProject.builder)
                    .map(key => {
                        const state = appState.activeProject.builder[key];
                        if (!state.active) return null;

                        let text = '';
                        if (key === 'context' || key === 'constraints') {
                            text = state.value || '';
                        } else {
                            text = state.promptValue || '';
                        }

                        if (!text.trim()) return null;

                        if (key === 'context') {
                            return `Use the following context:\n\n---\n${text}\n---`;
                        }
                        if (key === 'constraints') {
                            return `Apply the following constraints:\n${text}`;
                        }
                        return text;
                    })
                    .filter(text => text);

                const finalPrompt = appState.activeProject.contentBlocks.finalPrompt;
                const activeDraft = finalPrompt.drafts.find(d => d.id === finalPrompt.activeDraftId);
                if (activeDraft) activeDraft.content = allOutputs.join('\n\n');
                switchToTab('#refinement-panel');
            }

            // Component Handlers
            function handleAddComponent() {
                const inactiveComponent = Object.keys(appState.activeProject.builder).find(key => !appState.activeProject.builder[key].active);
                if (inactiveComponent) appState.activeProject.builder[inactiveComponent].active = true;
            }

            function handleRemoveComponent(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if (key && appState.activeProject.builder[key]) appState.activeProject.builder[key].active = false;
            }

            function handleComponentCheckbox(target) {
                const checkbox = target;
                const path = checkbox.dataset.path;
                if (path) {
                    const pathArray = path.split('.');
                    handleCheckboxChange(pathArray, checkbox.checked);
                }
            }

            function handleComponentActiveToggle(target) {
                const checkbox = target;
                const componentId = checkbox.dataset.componentId;
                const isChecked = checkbox.checked;

                if (!componentId) return;

                // Update the database
                fetch(`/api/user-components/${componentId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ is_active: isChecked })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to update component state on the server.');
                    }
                    // Update local state to match
                    const component = appState.activeProject.components.find(c => c.id == componentId);
                    if (component) {
                        component.is_active = isChecked;
                    }
                    
                    // The main render() call will handle UI updates
                    render();
                })
                .catch(error => {
                    console.error('Error updating component active state:', error);
                    // Optional: revert the checkbox state on failure
                    checkbox.checked = !isChecked;
                });
            }

            function handleComponentRename(target) {
                const input = target;
                const originalType = input.dataset.originalType;
                const newType = input.value.trim();
                
                if (newType && newType !== originalType) {
                    handleComponentTypeRename(originalType, newType);
                }
            }

            // Change Event Handlers
            function handleDraftSelect(target) {
                const blockKey = target.parentElement.dataset.contentBlock;
                if (blockKey) appState.activeProject.contentBlocks[blockKey].activeDraftId = target.value;
            }

            function handleTextTransformerOption(target) {
                const activeAction = appState.activeProject.textTransformer.activeAction;
                if(activeAction) {
                   appState.activeProject.textTransformer.actions[activeAction].activeOption = target.value;
                }
            }

            function handleComponentSelect(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if (key) {
                   updateComponentState(key, { selection: target.value });
                }
            }

            function handleComponentGroupCheckbox(target) {
                const isChecked = target.checked;
                const promptSetId = parseInt(target.dataset.promptSetId, 10);
                const componentTypeId = parseInt(target.dataset.componentTypeId, 10);

                if (isNaN(promptSetId) || isNaN(componentTypeId)) return;

                // Optimistically update local state for instant UI feedback
                const visibilityRecord = appState.activeProject.visibility.find(
                    v => v.prompt_set_id === promptSetId && v.component_type_id === componentTypeId
                );

                if (visibilityRecord) {
                    visibilityRecord.is_visible = isChecked ? 1 : 0;
                } else {
                    appState.activeProject.visibility.push({
                        prompt_set_id: promptSetId,
                        component_type_id: componentTypeId,
                        is_visible: isChecked ? 1 : 0
                    });
                }

                const activeSet = appState.activeProject.promptSets.find(ps => ps.id === promptSetId);
                if (activeSet && activeSet.set_key === appState.activeProject.activePromptSet) {
                    const componentType = appState.activeProject.components.find(c => c.component_type_id === componentTypeId)?.type_key;
                    if(componentType && appState.activeProject.builder[componentType]) {
                        appState.activeProject.builder[componentType].active = isChecked;
                    }
                }
                
                render(); // Re-render the UI immediately

                fetch('/api/prompt-set-visibility', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        promptSetId: promptSetId,
                        componentTypeId: componentTypeId,
                        isVisible: isChecked
                    })
                })
                .then(response => {
                    if (!response.ok) {
                        console.error('Failed to update visibility on the server. Reverting UI.');
                        if (visibilityRecord) visibilityRecord.is_visible = !isChecked ? 1 : 0;
                        render();
                    }
                })
                .catch(error => {
                    console.error('Error updating prompt set visibility:', error);
                    if (visibilityRecord) visibilityRecord.is_visible = !isChecked ? 1 : 0;
                    render();
                });
            }

            // Input Event Handlers
            function handleProjectTitleInput(target) {
                appState.activeProject.projectName = target.value;
            }

            function handleContentBlockInput(target) {
                const blockKey = target.id.replace('-textarea', '');
                const contentBlock = appState.activeProject.contentBlocks[blockKey];
                const activeDraft = contentBlock?.drafts.find(d => d.id === contentBlock.activeDraftId);
                if(activeDraft) activeDraft.content = target.value;
            }

            function handleComponentInput(target) {
                const componentDiv = target.closest('.prompt-builder__component');
                const key = componentDiv?.dataset.componentKey;
                if(key) {
                    const componentState = appState.activeProject.builder[key];
                    if ('value' in componentState) { // For context, constraints
                        componentState.value = target.value;
                    } else { // For role, task, etc.
                        componentState.promptValue = target.value;
                        // Only save to userValue if they are in custom mode
                        if (componentState.selection === 'custom') {
                            componentState.userValue = target.value;
                        }
                    }
                }
            }

            // --- EVENT LISTENERS & LOGIC ---
            function setupAppEventListeners() {
                const actionMap = {
                    click: {
                        // Project & Library Management
                        saveProject: handleProjectSave,
                        saveAsProject: handleProjectSaveAs,
                        loadProject: handleProjectLoad,
                        deleteProject: handleProjectDelete,
                        adminReset: handleAdminReset,
                        // Content Blocks & Drafts
                        draftSave: handleDraftSave,
                        draftDelete: handleDraftDelete,
                        insertOutline: handleInsertOutline,
                        copyToClipboard: handleCopyToClipboard,
                        clearContent: handleClearContent,
                        // Text Transformer
                        selectTextTransformerAction: handleTextTransformerAction,
                        executeTextTransform: handleTextTransformExecute,
                        copyUp: handleTextCopyUp,
                        // Prompt Builder
                        addComponent: handleAddComponent,
                        removeComponent: handleRemoveComponent,
                        assembleAll: handleAssembleAll,
                        // Database Admin
                        componentActiveToggle: handleComponentActiveToggle,
                        toggleAdminDetails: handleAdminToggleDetails,
                    },
                    change: {
                        draftSelect: handleDraftSelect,
                        selectTextTransformerOption: handleTextTransformerOption,
                        componentSelect: handleComponentSelect,
                        // Database Admin
                        componentGroupCheckbox: handleComponentGroupCheckbox,
                        componentRename: handleComponentRename,
                    },
                    input: {
                        projectTitleInput: handleProjectTitleInput,
                        contentBlockInput: handleContentBlockInput,
                        componentInput: handleComponentInput,
                    }
                };

                const appContainer = document.querySelector('.app-container');

                // Main Delegated Click Listener - HYBRID MODEL
                appContainer.addEventListener('click', e => {
                    const target = e.target;

                    // New declarative actions
                    const actionTarget = target.closest('[data-action]');
                    if (actionTarget) {
                        const action = actionTarget.dataset.action;
                        if (actionMap.click[action]) {
                            actionMap.click[action](actionTarget, e);
                            // Only trigger render for actions that require it
                            if (['saveProject', 'saveAsProject', 'loadProject', 'deleteProject', 'adminReset', 'draftSave', 'draftDelete', 'insertOutline', 'clearContent', 'selectTextTransformerAction', 'executeTextTransform', 'copyUp', 'addComponent', 'removeComponent', 'assembleAll'].includes(action)) {
                                render();
                            }
                            return; // Exit after handling declarative action
                        }
                    }

                    // Legacy imperative actions (to be phased out)
                    if (target.closest('.collapsible-panel__icon')) {
                        handlePanelToggle(target);
                    }
                    else if (target.closest('.prompt-set-selector')) {
                        handlePromptSetChange(target);
                    }
                    else if (target.closest('.tab-button')) {
                        handleTabSwitch(target);
                    }
                });

                // Main Delegated Change Listener - HYBRID MODEL
                appContainer.addEventListener('change', e => {
                    const target = e.target;

                    // New declarative actions
                    const actionTarget = target.closest('[data-action]');
                    if (actionTarget) {
                        const action = actionTarget.dataset.action;
                        if (actionMap.change[action]) {
                            actionMap.change[action](target, e);
                            if (['draftSelect', 'selectTextTransformerOption', 'componentSelect'].includes(action)) {
                                setTimeout(render, 0);
                            }
                            return;
                        }
                    }

                    // Legacy imperative actions (none remain)
                });

                // Main Delegated Input Listener - HYBRID MODEL
                appContainer.addEventListener('input', e => {
                    const target = e.target;
                    
                    // New declarative actions
                    const actionTarget = target.closest('[data-action]');
                    if (actionTarget) {
                        const action = actionTarget.dataset.action;
                        if (actionMap.input[action]) {
                            actionMap.input[action](target, e);
                            // Renders are not typically needed for input events
                            return; // Exit after handling declarative action
                        }
                    }
                    
                    // Legacy imperative actions (none remain)
                });
            }

            // --- DATA INITIALIZATION ---
            async function fetchAndInitializeData() {
                try {
                    const response = await fetch('/api/components');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
            
                    // Store all data in appState
                    appState.activeProject.components = data.components;
                    appState.activeProject.promptSets = data.promptSets;
                    appState.activeProject.visibility = data.visibility;
            
                    // Dynamically build the builderComponentData from the API response
                    builderComponentData = {};
                    data.types.forEach(type => {
                        builderComponentData[type.type_key] = {
                            title: type.display_name,
                            prompts: {}
                        };
                    });
                    data.components.forEach(component => {
                        if (builderComponentData[component.type_key]) {
                            builderComponentData[component.type_key].prompts[component.selection] = component.prompt_value;
                        }
                    });
            
                    // New logic: Initialize builder state based on persisted data
                    const builderState = {};
                    data.types.forEach(type => {
                        const hasActiveComponent = data.components.some(c => c.type_key === type.type_key && c.is_active);
                        builderState[type.type_key] = {
                            active: hasActiveComponent,
                            selection: 'custom',
                            promptValue: '',
                            userValue: ''
                        };
                         // For context and constraints, which don't have selections/prompts
                        if (type.type_key === 'context' || type.type_key === 'constraints') {
                           builderState[type.type_key].value = '';
                        }
                    });
                    appState.activeProject.builder = builderState;

                    console.log('Successfully fetched and initialized data:', {
                        appStateComponents: appState.activeProject.components.length,
                        promptSets: appState.activeProject.promptSets.length,
                        visibilityRecords: appState.activeProject.visibility.length,
                        builderComponentData: builderComponentData
                    });
            
                    // Now that data is loaded, initialize the components admin panel and render UI
                    await renderComponentsAdmin();
                    renderPromptSetSelectors(); // This function should be updated to use the new promptSets data
                    applyPromptSet(appState.activeProject.activePromptSet); // Apply default prompt set
                    render(); // Final render after all data is ready

                } catch (error) {
                    console.error('Failed to fetch initial component data:', error);
                    const errorMessage = document.getElementById('error-message');
                    if (errorMessage) {
                        errorMessage.textContent = 'Failed to load application data. Please try refreshing the page.';
                        errorMessage.style.display = 'block';
                    }
                }
            }

            function updateComponentState(key, newState) {
                const componentState = appState.activeProject.builder[key];
                const componentData = builderComponentData[key];
                if (!componentState) return;

                // Update the selection state
                Object.assign(componentState, newState);

                if (newState.selection === 'custom') {
                    // If user selects "Write My Own...", restore their saved text.
                    componentState.promptValue = componentState.userValue;
                } else {
                    // If user selects a pre-defined prompt, load it.
                    if (componentData && componentData.prompts) {
                        componentState.promptValue = componentData.prompts[newState.selection] || '';
                    }
                }
            }

            // Generic checkbox handler for all checkbox interactions
            function handleCheckboxChange(checkboxPath, value) {
                // This robustly navigates the path, creating nested objects if they don't exist.
                let target = appState;
                for (let i = 0; i < checkboxPath.length - 1; i++) {
                    const segment = checkboxPath[i];
                    if (target[segment] === undefined) {
                        // Create the missing object if it doesn't exist.
                        target[segment] = {};
                    }
                    target = target[segment];
                }

                // Set the final property
                const finalKey = checkboxPath[checkboxPath.length - 1];
                target[finalKey] = value;
                
                // Check if this change affects the current prompt set
                if (checkboxPath[0] === 'activeProject' && checkboxPath[1] === 'promptSets') {
                    const promptSetKey = checkboxPath[2];
                    const componentType = checkboxPath[3];
                    
                    // If this is the current active prompt set, update the builder
                    if (promptSetKey === appState.activeProject.activePromptSet) {
                        // For Custom Build, ensure the component exists in the builder
                        if (!appState.activeProject.builder[componentType]) {
                            appState.activeProject.builder[componentType] = { active: true, selection: 'custom', promptValue: '', userValue: '' };
                        }
                        appState.activeProject.builder[componentType].active = value;
                    }
                }
                
                // Trigger UI update
                render();
            }

            // Function to update component type references in appState when renaming
            async function handleComponentTypeRename(oldType, newType) {
                console.log('=== RENAME DEBUG ===');
                console.log('Renaming from:', oldType, 'to:', newType);
                console.log('Before update - builderComponentData:', builderComponentData);
                
                try {
                    updateComponentTypeInAppState(oldType, newType);
                    console.log('After update - builderComponentData:', builderComponentData);
                    
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.dataset.originalType = newType;
                    }
                    
                    // ADD: Re-render to update Prompt Builder
                    console.log('Calling render() to update UI...');
                    render();
                    console.log('=== END RENAME DEBUG ===');
                    
                } catch (error) {
                    console.error('Error renaming component:', error);
                    const input = document.querySelector(`[data-original-type="${oldType}"]`);
                    if (input) {
                        input.value = oldType;
                    }
                }
            }

            function updateComponentTypeInAppState(oldName, newName) {
                console.log(`Updating component type from "${oldName}" to "${newName}" in appState`);
                
                // Update builder references
                if (appState.activeProject.builder[oldName]) {
                    appState.activeProject.builder[newName] = appState.activeProject.builder[oldName];
                    delete appState.activeProject.builder[oldName];
                }
                
                // Update promptActiveStates references
                if (appState.activeProject.promptActiveStates[oldName]) {
                    appState.activeProject.promptActiveStates[newName] = appState.activeProject.promptActiveStates[oldName];
                    delete appState.activeProject.promptActiveStates[oldName];
                }
                
                // Update promptSets references
                Object.keys(appState.activeProject.promptSets).forEach(promptSetKey => {
                    const promptSet = appState.activeProject.promptSets[promptSetKey];
                    if (promptSet[oldName]) {
                        promptSet[newName] = promptSet[oldName];
                        delete promptSet[oldName];
                    }
                });
                
                // Update builderComponentData references
                if (builderComponentData[oldName]) {
                    builderComponentData[newName] = builderComponentData[oldName];
                    builderComponentData[newName].title = newName.charAt(0).toUpperCase() + newName.slice(1);
                    delete builderComponentData[oldName];
                }
                
                console.log('appState updated successfully');
            }

            // --- COMPONENTS ADMIN FUNCTIONALITY ---
            async function renderComponentsAdmin() {
                const groupedView = document.getElementById('components-grouped-view');
                if (!groupedView) return;

                // Use appState components which are now populated by fetchAndInitializeData
                const components = appState.activeProject.components;

                // Group components by type_key
                const grouped = {};
                components.forEach(component => {
                    const type = component.type_key;
                    if (!grouped[type]) grouped[type] = [];
                    grouped[type].push(component);
                });

                // Get all component types from the builderComponentData to ensure all are rendered
                const allTypeKeys = Object.keys(builderComponentData).sort();

                groupedView.innerHTML = '';

                allTypeKeys.forEach(type => {
                    const groupSection = document.createElement('div');
                    groupSection.className = 'component-group';
                    
                    // Group title with checkbox
                    const groupTitle = document.createElement('div');
                    groupTitle.className = 'group-title';
                    groupTitle.innerHTML = `
                        <div class="group-title__row">
                            <div class="group-title__label">
                                <input type="text" class="group-title__editable-text" value="${type}" data-original-type="${type}" data-action="componentRename">
                            </div>
                        </div>
                    `;
                    groupSection.appendChild(groupTitle);

                    // Create flex container for side-by-side layout
                    const flexContainer = document.createElement('div');
                    flexContainer.className = 'component-group__layout';

                    // Left side - Table
                    const tableContainer = document.createElement('div');
                    tableContainer.className = 'component-group__table-container';

                    // Table for subcomponents
                    const table = document.createElement('table');
                    table.id = `component-table--${type}`;
                    const thead = document.createElement('thead');
                    thead.innerHTML = `
                        <tr>
                            <th class="table__header--active">Active</th>
                            <th class="table__header--selection">Selection</th>
                            <th class="table__header--prompt">Prompt Value</th>
                        </tr>
                    `;
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');
                    // Sort by created_at descending
                    if (grouped[type]) {
                        grouped[type].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                        grouped[type].forEach(component => {
                            // Main row (Tier 1)
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td class="table__cell--active"><input type="checkbox" ${component.is_active ? 'checked' : ''} class="component-active-checkbox" data-component-id="${component.id}" data-action="componentActiveToggle"></td>
                                <td class="table__cell--selection"><input type="text" value="${component.selection || ''}" class="input--selection"></td>
                                <td class="table__cell--prompt"><textarea class="textarea--prompt">${component.prompt_value || ''}</textarea></td>
                            `;
                            tbody.appendChild(row);

                            // Details row for Tier 2
                            const detailsRow = document.createElement('tr');
                            detailsRow.className = 'tier2-details-row';
                            detailsRow.style.display = showAdminDetails ? '' : 'none';
                            const detailsCell = document.createElement('td');
                            detailsCell.colSpan = 3;
                            detailsCell.innerHTML = `
                                <div class="tier2-details-box">
                                    <strong>ID:</strong> ${component.id} &nbsp;|
                                    <strong>User Value:</strong> ${component.user_value || ''} &nbsp;|
                                    <strong>Created At:</strong> ${new Date(component.created_at).toLocaleString()} &nbsp;|
                                    <strong>Modified At:</strong> ${new Date(component.modified_at).toLocaleString()} &nbsp;|
                                    <strong>Is Starter:</strong> ${component.is_starter ? 'Yes' : 'No'}
                                </div>
                            `;
                            detailsRow.appendChild(detailsCell);
                            tbody.appendChild(detailsRow);
                        });
                    }

                    table.appendChild(tbody);
                    tableContainer.appendChild(table);

                    // Right side - Content Box
                    const contentBox = document.createElement('div');
                    contentBox.className = 'component-group__content-box';
                    
                    // Find the component_type_id for the current group
                    const componentType = appState.activeProject.components.find(c => c.type_key === type);
                    const componentTypeId = componentType?.component_type_id;

                    let contentHTML = `<h4>Prompt Set Status</h4>`;
                    contentHTML += `<p>Select which prompt set should include this component group:</p>`;

                    if (componentTypeId) {
                        appState.activeProject.promptSets.forEach(promptSet => {
                            let isVisible = false;
                            // Find the visibility record for this specific combination
                            const visibilityRecord = appState.activeProject.visibility.find(
                                v => v.prompt_set_id === promptSet.id && v.component_type_id === componentTypeId
                            );
                            if (visibilityRecord) {
                                isVisible = !!visibilityRecord.is_visible;
                            }

                            const statusText = isVisible ? 'Active' : 'Inactive';
                            const itemClass = isVisible ? 'component-group__prompt-set-item component-group__prompt-set-item--active' : 'component-group__prompt-set-item component-group__prompt-set-item--inactive';
                            const statusClass = isVisible ? 'component-group__status-text component-group__status-text--active' : 'component-group__status-text component-group__status-text--inactive';

                            contentHTML += `
                                <div class="${itemClass}">
                                    <input type="checkbox" ${isVisible ? 'checked' : ''} class="component-group__prompt-set-checkbox" 
                                           data-component-type-id="${componentTypeId}" 
                                           data-prompt-set-id="${promptSet.id}"
                                           data-action="componentGroupCheckbox">
                                    <span class="component-group__prompt-set-name">${promptSet.display_name}</span>
                                    <span class="${statusClass}">${statusText}</span>
                                </div>
                            `;
                        });
                    }
                    
                    contentBox.innerHTML = contentHTML;

                    // Add both to flex container
                    flexContainer.appendChild(tableContainer);
                    flexContainer.appendChild(contentBox);
                    
                    groupSection.appendChild(flexContainer);
                    groupedView.appendChild(groupSection);
                });
            }

            // --- INITIALIZATION ---
            setupUIEventListeners();
            setupAppEventListeners(); // Attach main app event listeners
            
            // Fetch data and then initialize the rest of the app
            fetchAndInitializeData();
        });
    </script>
</body>
</html>